[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to R and Python",
    "section": "",
    "text": "Introduction\nThis book consists of lecture notes from the short course Introduction to Programming Languages R and Python.\nIf you are interested in the fundamentals of the R language, you can find these topics in the first part of the book. On the other hand, if you want to explore the fundamentals of Python, the second part is where you will find that information.\nThis is a continuously evolving book, designed to grow and adapt. If you have any suggestions or feedback on the content presented, feel free to send an email to magnotairone[at]gmail.com.\nMy sincere thanks to Luiza Tuler for reviewing the content of this book."
  },
  {
    "objectID": "01-fundamentos_r.html#rstudio",
    "href": "01-fundamentos_r.html#rstudio",
    "title": "1  R Fundamentals",
    "section": "1.1 RStudio",
    "text": "1.1 RStudio\nTo install R, download it from http://www.r-project.org. Then, install the IDE (Integrated Development Environment) R Studio.\nWhen you open RStudio, click on the File/ New File/ R Script menu (or press Ctrl+Shift+N). You should see a structure similar to the one shown in the figure below.\n\n\n\nRStudio Interface\n\n\nNote that there are four panels:\n\nScript Panel (top left): This panel is where you can write, edit, and run R scripts. It provides features such as syntax highlighting, autocomplete, and code checking to assist with coding.\nConsole Panel (bottom left): The console is where R code is executed and results are displayed. You can enter commands directly here and see the results immediately. It also maintains a history of executed commands, which can be useful for future reference.\nEnvironment/Workspace (top right): This panel displays information about objects (such as variables, functions, etc.) currently loaded in R’s memory. It shows details such as the object’s name, type, and current value. This is useful for monitoring and managing objects during a work session.\nFiles/Plots/Packages/Help (bottom right): A panel with various features.\n\nFiles: This tab allows you to browse and manage your project’s files. You can create, rename, delete, and organize files and folders directly within RStudio.\nPlots: Here, the plots generated by R are displayed. When you create a plot using visualization functions in R, the result is shown in this tab. This facilitates visual data analysis and inspection during the creation process.\nPackages: In this tab, you can view and manage the packages installed in your R environment. It displays a list of all installed packages, along with their version and status (loaded or not). Additionally, you can install new packages, update existing ones, and load or unload packages as needed for your work.\nHelp: This tab provides quick access to documentation and help information about R functions, packages, and other resources. You can search for specific topics and access the official documentation directly within RStudio. This is useful for obtaining information about a function’s syntax, usage examples, and details about available parameters."
  },
  {
    "objectID": "01-fundamentos_r.html#sec-datatypes",
    "href": "01-fundamentos_r.html#sec-datatypes",
    "title": "1  R Fundamentals",
    "section": "1.2 Data Types",
    "text": "1.2 Data Types\nWhenever you learn a new programming language, it’s essential to first understand the basic data types it supports.\nIn R, there are four basic data types available: numeric, logical, character, and factor.\n\n1.2.1 Numeric Data Type\nNumeric data is used to express quantitative values, such as prices, rates, and quantities, and is represented by integers or decimals.\n\n# Integer representing the number of shares in a portfolio\nnum_shares &lt;- 100\n\n# Floating-point number representing the inflation rate\ninflation_rate &lt;- 3.5\n\n# Checking the class of inflation_rate\nclass(inflation_rate)\n\n[1] \"numeric\"\n\n\nThe class() function is used to determine the class of a variable. In other words, it provides information about the type of data that a variable represents. In the example above, the inflation_rate variable belongs to the numeric class.\n\n\n1.2.2 Logical Data Type\nLogical data is used to represent states or conditions, such as true or false, and is useful in logical operations and comparisons.\n\n# Checking if the interest rate is increasing\ninterest_rate_rising &lt;- TRUE\n\n# Checking if share prices are falling\nshare_price_falling &lt;- FALSE\n\n# Checking the class of share_price_falling\nclass(share_price_falling)\n\n[1] \"logical\"\n\n\n\n\n1.2.3 Character Data Type\nCharacter data is used to represent text, such as country names, company names, or categories, and is essential for descriptive analyses and communication of results.\n\n# Name of a country\ncountry &lt;- \"Brazil\"\n\n# Name of a multinational company\ncompany &lt;- \"Petróleo Brasileiro S.A.\"\n\n# Checking the class of country\nclass(country)\n\n[1] \"character\"\n\n\n\n\n1.2.4 Factor Data Type\nFactors are used to represent categorical variables, such as classifications, categories, or groups, offering an efficient way to handle discrete and qualitative data.\n\n# Credit risk classification of a company\ncredit_risk &lt;- factor(c(\"Low\", \"Medium\", \"High\", \"Low\", \"High\"))\n\n# Checking the class of credit_risk\nclass(credit_risk)\n\n[1] \"factor\"\n\n\nThe levels() function returns the levels (or categories) of a factor. This is useful to understand which categories are represented and to perform data manipulation operations based on these categories.\n\n# displaying credit risk levels\nlevels(credit_risk)\n\n[1] \"High\"   \"Low\"    \"Medium\""
  },
  {
    "objectID": "01-fundamentos_r.html#r-language-fundamentals",
    "href": "01-fundamentos_r.html#r-language-fundamentals",
    "title": "1  R Fundamentals",
    "section": "1.3 R language fundamentals",
    "text": "1.3 R language fundamentals\nThe R environment refers to the workspace where all variables, functions, and objects created during an R session are stored and managed. The environment includes both the objects you create and those that are automatically loaded via packages or other data import mechanisms (more on packages in Section 2.4).\nFor example, using the ls() function (which lists the names of objects in the current environment), we can see all objects currently present in the R environment.\n\nls()\n\nIf you have correctly executed all the commands in Section 1.2, you should see the following output in the console:\n[1] \"company\"               \"country\"                  \"num_shares\"\n[4] \"share_price_falling\"     \"inflation_rate\"         \"interest_rate_rising\""
  },
  {
    "objectID": "01-fundamentos_r.html#variables",
    "href": "01-fundamentos_r.html#variables",
    "title": "1  R Fundamentals",
    "section": "1.4 Variables",
    "text": "1.4 Variables\nIn Section 1.2, several variables were created. For example, the company variable stores a character string. Previously, you saw how to list all defined variables in your environment. But what exactly are variables?\nIn R, variables are fundamental elements used to store and manipulate data. They are like containers that hold values, objects, or expressions. When you assign a value to a variable, you are essentially giving it a name to access and manipulate it later.\nFor example, by writing share_price &lt;- 10, you are creating a variable called share_price and assigning it the value 10. Now, whenever you use share_price in your code, you are referring to this value.\nIt is a common practice to choose descriptive variable names that help understand their purpose or content. For example, in an economic context, you might use share_price to represent a shares’s price or inflation_rate to represent the inflation rate.\nTo assign a value to a variable, use the &lt;- operator. The = operator can also be used for assignment. Both have the same practical effect in R, and the choice between them usually comes down to personal preference and coding style, although some style guides recommend using &lt;-."
  },
  {
    "objectID": "01-fundamentos_r.html#checking-the-type-of-a-variable",
    "href": "01-fundamentos_r.html#checking-the-type-of-a-variable",
    "title": "1  R Fundamentals",
    "section": "1.5 Checking the Type of a Variable",
    "text": "1.5 Checking the Type of a Variable\nWe can use the is.* family of functions to verify the types of some variables in our workspace.\n\nFor the company variable:\n\n\nis.character(company)\n\nThis will return TRUE if the company variable is of type character.\n\nFor the country variable:\n\n\nis.character(country)\n\nJust like for the variable company, this will return TRUE if the variable country is of type character.\n\nFor the variable num_shares:\n\n\nis.numeric(num_shares)\n\nThis will return TRUE if the variable num_shares is of type numeric.\n\nFor the variable share_price_falling:\n\n\nis.logical(share_price_falling)\n\nThis will return TRUE if the variable share_price_falling is of type logical.\n\nFor the variable inflation_rate:\n\n\nis.numeric(inflation_rate)\n\nJust like for the variable num_shares, this will return TRUE if the variable inflation_rate is of type numeric.\n\nFor the variable interest_rate_rising:\n\n\nis.logical(interest_rate_rising)\n\nThis will return TRUE if the variable interest_rate_rising is of type logical.\nThese examples illustrate how you can use the is.* functions to check the type of variables, helping ensure that you are handling data correctly in your analyses.\nAnother important family of functions is the as.* functions. They are used to convert an object from one type to another. They allow changing the data type of a variable, which can be useful in various situations, such as performing specific operations that require a certain data type or ensuring data type consistency in the code.\nSome of the most common as.* functions include:\n\nas.character() converts to character:\n\n\nnumber &lt;- 123\nnumber_character &lt;- as.character(number)\n\n\nas.numeric() converts to numeric:\n\n\ntext &lt;- \"3.14\"\nnumber &lt;- as.numeric(text)\n\n\nas.logical() converts to logical:\n\n\nnumber &lt;- 0\nlogical &lt;- as.logical(number)\n\nThese functions are useful for ensuring that data types are correct in your code and for guaranteeing that you can perform the desired operations on your objects.\nHowever, it is important to note that not all conversions may be successful, especially when there is a loss of information (e.g., when converting from character to numeric).\nTherefore, it is always a good practice to verify if the conversion was done correctly and if the resulting data is as expected.\nHere is an example of converting a character to numeric with non-numeric text:\n\ntext &lt;- \"abc\"\nnumber &lt;- as.numeric(text)\n\nWarning: NAs introduzidos por coerção\n\n\nIn this case, the conversion will fail, returning NA (Not Available) and issuing a warning message."
  },
  {
    "objectID": "01-fundamentos_r.html#data-structures",
    "href": "01-fundamentos_r.html#data-structures",
    "title": "1  R Fundamentals",
    "section": "1.6 Data structures",
    "text": "1.6 Data structures\nIn any data analysis, it is common to work with datasets that have different structures and formats.\nLet’s explore four fundamental data structures in R: vector, matrix, list, and DataFrame.\n\n1.6.1 Vectors\nA vector in R is a one-dimensional data structure with elements of the same type. Use c() to create vectors:\n\n# share prices vector\nshare_prices &lt;- c(100, 110, 105, 120, 115)\n\nIn some cases, it is useful to define sequences of numbers using the : operator and the seq() function.\n\n# Sequence from 1 to 10:\nsequence &lt;- 1:10\nsequence\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n# Sequence from 1 to 10 with an increment of 2:\nincrement_sequence &lt;- seq(1, 10, by = 2)\nincrement_sequence\n\n[1] 1 3 5 7 9\n\n\nTo check the size of a vector, you can use the length() function.\n\n# checking the size of the share prices vector\nlength(share_prices)\n\n[1] 5\n\nlength(1:10)\n\n[1] 10\n\n\nTo access elements in a vector in R, you can use numeric or logical indices inside square brackets [ ].\nYou can access elements using numeric indices within square brackets [ ].\nFor example, vector[i] accesses the element at position i of vector.\n\n# share prices vector\nshare_prices &lt;- c(100, 110, 105, 120, 115)\n\n# Accessing the second element of the vector\nsecond_element &lt;- share_prices[2]\n\n# Accessing a range of elements from the vector\nmultiple_elements &lt;- share_prices[3:5]\n\nYou can also access elements using logical indices inside square brackets [ ].\nFor example, vector[logical_indices] returns the elements of the vector where the logical indices are TRUE.\n\n# Accessing share prices greater than 110\nprices_above_110 &lt;- share_prices[share_prices &gt; 110]\n\n\n\n\n1.6.2 Matrices\nA matrix in R is a two-dimensional data structure consisting of rows and columns of elements of the same type.\nIt is useful for representing tabular datasets, such as time series data or covariance matrices.\n\n# Asset returns matrix\nasset_returns &lt;- matrix(c(0.05, 0.03, 0.02, 0.04, 0.06, 0.03), \n                        nrow = 2, byrow = TRUE)\nrownames(asset_returns) &lt;- c(\"Share 1\", \"Share 2\")\ncolnames(asset_returns) &lt;- c(\"Year 1\", \"Year 2\", \"Year 3\")\n\nThe code above creates a matrix called asset_returns that stores the returns of two assets over three years.\nThe matrix() function is used to create the matrix.\nThe vector c(0.05, 0.03, 0.02, 0.04, 0.06, 0.03) contains the return values, filled row by row.\nParameters nrow = 2 and byrow = TRUE specify that the matrix should have 2 rows (to represent two assets), and values are filled by row.\nThe rownames() and colnames() functions assign names to the rows (“Share 1” and “Share 2”) and columns (“Year 1”, “Year 2”, “Year 3”).\nThe class() function returns the class of the object, which in this case will be “matrix,” indicating that asset_returns is a matrix in R.\nThe dim() function returns the dimensions of the matrix, i.e., the number of rows and columns.\n\n# Verifying the matrix dimensions\ndim(asset_returns)\n\n[1] 2 3\n\n\nThis will output [2, 3], indicating that the matrix has 2 rows and 3 columns.\nThe length() function returns the total number of elements in an object.\nFor a matrix, this will return the total number of elements, which is the product of the number of rows and columns.\n\nlength(asset_returns)\n\n[1] 6\n\n\nTo access rows, columns, and elements in a matrix in R, you can use numeric indices or names (if defined).\nHere’s how to do it:\n\nAccessing Rows and Columns: You can access rows and columns using numeric indices inside square brackets [ ]. For example, matrix[i, ] accesses row i, and matrix[, j] accesses column j. To access a specific cell, you use matrix[i, j], where i is the row number and j is the column number.\n\n\n# Accessing the first row of the matrix\nfirst_row &lt;- asset_returns[1, ]\n\n# Accessing the second column of the matrix\nsecond_column &lt;- asset_returns[, 2]\n\n# Accessing the element in the second row and third column\nelement &lt;- asset_returns[2, 3]\n\n# Accessing more than one column\nselected_columns &lt;- asset_returns[, c(1, 3)]\n\n\nAccessing Rows and Columns by name:If row or column names are defined, you can also use them to access data:\n\n\n# Accessing the row named \"Share 1\"\nshare1 &lt;- asset_returns[\"Share 1\", ]\n\n# Accessing the column named \"Year 2\"\nyear2 &lt;- asset_returns[, \"Year 2\"]\n\n# Accessing the element in \"Share 2\" and \"Year 3\"\nspecific_element &lt;- asset_returns[\"Share 2\", \"Year 3\"]\n\nIn R, unlike other programming languages, the indices of rows and columns in matrices (as well as in vectors, lists, etc.) start at 1 instead of 0.\nThis means the first element of a matrix is at index 1, the second at index 2, and so on.\n\n\n1.6.3 Lists\nIn R, a list is a flexible data structure that can store elements of different types, such as vectors, matrices, other lists, or even functions. Lists are useful when you need to store and manipulate heterogeneous data sets or complex structures.\nWe can create a list that stores information about a country, such as its name, GDP, inflation rate, and a time series of exchange rate values.\n\n# Creating a list with country information\ncountry_info &lt;- list(\n  name = \"Brazil\",\n  gdp = 1609,\n  inflation = 0.05,\n  exchange_rates = c(4.86, 5.13, 5.20, 5.07, 4.97)\n)\n\nIn this example, country_info is a list containing four elements:\n\nname: the name of the country (character type).\n\ngdp: the country’s Gross Domestic Product (numeric type).\n\ninflation: the country’s inflation rate (numeric type).\n\nexchange_rates: a time series of the country’s exchange rate values (numeric vector type).\n\nThis list exemplifies how we can store different types of data in a list in R.\nIt can be used to represent a country’s economic information in an organized and accessible manner.\nTo access individual elements in a list by name, we use the dollar operator $.\n\n# Accessing the name of the country\ncountry_info$name\n\n[1] \"Brazil\"\n\n# Accessing the GDP\ncountry_info$gdp\n\n[1] 1609\n\n# Accessing exchange rates\ncountry_info[[\"exchange_rates\"]][3]\n\n[1] 5.2\n\n\nWe can also access individual elements in a list by index using square brackets [ ].\n\n# Accessing the first element of the list (country name)\nfirst_element &lt;- country_info[[1]]\n\n# Accessing the third element of the list (inflation rate)\nthird_element &lt;- country_info[[3]]\n\nYou may have noticed the use of double brackets to access list elements.\nIn R, single brackets ([]) and double brackets ([[]]) serve different purposes when accessing elements in a list.\nUnderstanding Lists Through the Train Analogy\nImagine a list in R as a train, and each element of the list is a wagon of the train.\nNow, inside each wagon, you can store different types of cargo, such as boxes, sacks, or even other wagons.\nFor instance, in one wagon, you might have a vector; in another, a matrix; and in another, just a single number.\nEach element of the list can be different in type and content, just as each wagon of a train can hold different things.\nAccessing a Specific Wagon\nTo access specific information about Brazil, such as the country name or GDP, we use single brackets [ ].\nFor example:\n\ncountry_info[\"nome\"]: we get the wagon containing the country name, which is “Brazil”.\n\ncountry_info[2]: we get the second wagon, which contains the GDP, with a value of 1609.\n\nAccessing Elements Inside a Wagon\nIf we want to access specific elements inside a wagon, we use double brackets [[ ]].\nFor example:\n\ncountry_info[[\"exchange_rates\"]]: we open the wagon containing the country’s exchange rate information and access its contents, which is a vector of different exchange rate values over time.\n\nTo access a specific value from this vector, we can use single brackets [ ] again:\n\ncountry_info[[\"exchange_rates\"]][3]: this opens the wagon containing the exchange rate vector and retrieves the third value, which is 5.20.\n\nUsing the class() function, we can observe the difference between objects obtained with single and double brackets.\n\nclass(country_info[\"nome\"])\n\n[1] \"list\"\n\nclass(country_info[[\"nome\"]])\n\n[1] \"NULL\"\n\n\n\n\n\n\n\n\nSummary\n\n\n\nIn summary, single brackets are used to access subsets of elements in a list while preserving their structure, whereas double brackets are used to access individual values from a list, without preserving the original structure.\n\n\n\n\n\n1.6.4 DataFrames\nDataFrames are tabular structures in R where columns can have different types.\nYou can create one using the data.frame() function:\n\n# Creating a dataframe with economic data\neconomic_data &lt;- data.frame(\n  country = c(\"Brazil\", \"USA\", \"China\", \"India\", \"Japan\"),\n  continent = factor(c(\"America\", \"America\", \"Asia\", \"Asia\", \"Asia\")),\n  population = c(213, 328, 1441, 1380, 126),\n  gdp_per_capita = c(10294, 65741, 10380, 2353, 41581),\n  inflation = c(0.02, 0.01, 0.04, 0.06, 0.005)\n)\n\nWe can access individual elements, rows, or columns of a dataframe using numeric indices or column names.\n\n# Accessing the first row of the dataframe\n(first_row &lt;- economic_data[1, ])\n\n  country continent population gdp_per_capita inflation\n1  Brazil   America        213          10294      0.02\n\n# Accessing the \"country\" column of the dataframe\n(country &lt;- economic_data$country)\n\n[1] \"Brazil\" \"USA\"    \"China\"  \"India\"  \"Japan\" \n\n# Accessing the element in the second row and third column of the dataframe\n(element &lt;- economic_data[2, 3])\n\n[1] 328\n\n\nWe can combine dataframes based on common columns using the merge() function.\n\n# Creating another dataframe for merging\ndemographic_data &lt;- data.frame(\n  country = c(\"China\", \"India\", \"Japan\", \"Brazil\", \"USA\"),\n  life_expectancy = c(76, 69, 84, 75, 79)\n)\n\n# Performing a merge based on the \"country\" column\n(data_and_demographic_info &lt;- merge(economic_data, demographic_data, by = \"country\"))\n\n  country continent population gdp_per_capita inflation life_expectancy\n1  Brazil   America        213          10294     0.020              75\n2   China      Asia       1441          10380     0.040              76\n3   India      Asia       1380           2353     0.060              69\n4   Japan      Asia        126          41581     0.005              84\n5     USA   America        328          65741     0.010              79\n\n\nWe can also add new rows of data to an existing dataframe.\n\n# Creating another dataframe to combine rows\nmore_data &lt;- data.frame(\n  country = c(\"South Africa\", \"Germany\"),\n  continent = c(\"Africa\", \"Europe\"),\n  population = c(60, 83),\n  gdp_per_capita = c(6151, 52947),\n  inflation = c(0.025, NA),\n  life_expectancy = c(58, 81)\n)\n\n# Combining dataframes by rows\n(all_data &lt;- rbind(data_and_demographic_info, more_data))\n\n       country continent population gdp_per_capita inflation life_expectancy\n1       Brazil   America        213          10294     0.020              75\n2        China      Asia       1441          10380     0.040              76\n3        India      Asia       1380           2353     0.060              69\n4        Japan      Asia        126          41581     0.005              84\n5          USA   America        328          65741     0.010              79\n6 South Africa    Africa         60           6151     0.025              58\n7      Germany    Europe         83          52947        NA              81\n\n\nWe can obtain information about the size of the dataframe using the dim(), nrow(), and ncol() functions:\n\ndim(all_data)  # Returns the number of rows and columns in the dataframe\n\n[1] 7 6\n\nnrow(all_data) # Returns only the number of rows\n\n[1] 7\n\nncol(all_data) # Returns only the number of columns\n\n[1] 6\n\n\n\n\n\n\n\n\nMissing Data\n\n\n\nYou may have noticed in the more_data dataframe that the inflation value for Germany is marked as NA.\nAn NA value, short for “Not Available,” indicates a missing value in a dataset.\nIn the example above, the presence of NA in the inflation column for Germany means that no inflation value is available for this country in the provided table.\nA value can be marked as NA in various situations, including:\n\nMissing data: When no information is available for a specific field in a dataset.\nExample: Lack of data on unemployment rates in certain regions due to unavailability or incomplete reporting.\nMeasurement or collection errors: Errors during the measurement or data collection process can result in inaccurate or missing values.\nExample: Recording a country’s GDP might lead to missing values for certain quarters due to collection errors.\nInapplicable values: Some variables might not apply to all cases.\nExample: In analyzing government spending on education, some countries might not have data due to differences in reporting policies or lack of investment in education.\nUnrecorded values: In some databases, specific values might not be recorded intentionally, either for privacy reasons or because they are irrelevant to the analysis.\nExample: Collecting data on individuals’ net worth in an income survey might result in some participants opting not to disclose financial information for privacy reasons. In such cases, the corresponding values would be marked as NA.\n\n\n\n\n\nIf we want to filter data based on a specific criterion, we can use logical operators along with dataframe indexing:\n\nall_data$continent == \"Asia\"  # Returns a logical vector indicating which rows belong to the \"Asia\" continent\n\n[1] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\nall_data[all_data$continent == \"Asia\", ]  # Filters and returns only the rows where the continent is \"Asia\"\n\n  country continent population gdp_per_capita inflation life_expectancy\n2   China      Asia       1441          10380     0.040              76\n3   India      Asia       1380           2353     0.060              69\n4   Japan      Asia        126          41581     0.005              84\n\nall_data$continent == \"Asia\" & !is.na(all_data$continent)  # Ensures we exclude missing values before filtering\n\n[1] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\nall_data[all_data$continent == \"Asia\" & !is.na(all_data$continent), ]  # Filters rows where the continent is \"Asia\", ignoring missing values\n\n  country continent population gdp_per_capita inflation life_expectancy\n2   China      Asia       1441          10380     0.040              76\n3   India      Asia       1380           2353     0.060              69\n4   Japan      Asia        126          41581     0.005              84\n\n\nWe can also find specific rows based on conditions applied to numerical columns:\n\nall_data$population == max(all_data$population)  # Returns a logical vector indicating the row(s) with the maximum population\n\n[1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n\nwhich(all_data$population == max(all_data$population))  # Returns the index of the row(s) where the population is maximum\n\n[1] 2\n\nindex &lt;- which(all_data$population == max(all_data$population))  # Stores the index of the maximum population row(s)\n\nall_data[index, ]  # Retrieves the row(s) corresponding to the maximum population\n\n  country continent population gdp_per_capita inflation life_expectancy\n2   China      Asia       1441          10380      0.04              76"
  },
  {
    "objectID": "01-fundamentos_r.html#exercises",
    "href": "01-fundamentos_r.html#exercises",
    "title": "1  R Fundamentals",
    "section": "1.7 Exercises",
    "text": "1.7 Exercises\n\nConsider the following economic sectors: “Finance,” “Information Technology,” “Industrial Goods,” and “Healthcare.” Generate a random sample of size 1,000 from these sectors with equal probability for each. Display the first few values of the resulting variable and count how many companies belong to each economic sector."
  },
  {
    "objectID": "02-fluxos.html#conditional-structures",
    "href": "02-fluxos.html#conditional-structures",
    "title": "2  Execution Flows",
    "section": "2.1 Conditional Structures",
    "text": "2.1 Conditional Structures\nCode flow in R can be controlled using conditional structures, such as if, else if, and else. These structures allow you to execute different code blocks based on specific conditions.\n\n2.1.1 if and else\nThe if structure is a control flow structure that executes a block of code if a specified condition is true. If the condition is false, the code block within the if will not be executed. On the other hand, else is used to execute a block of code when the if condition is false.\nThe basic syntax of if and else in R is as follows:\n\nif (condition) {\n  # Code block to execute if the condition is true\n} else {\n  # Code block to execute if the condition is false\n}\n\nHere is a practical example of how to use if and else to check if a randomly chosen integer between -10 and 10 is positive or negative:\n\n# Setting the seed to ensure reproducibility\nset.seed(42)\n\n# Generating a random number between -10 and 10\nnumber &lt;- sample(-10:10, 1)\n\nif (number &gt; 0) {\n  print(\"The number is positive.\")\n} else {\n  print(\"The number is negative or zero.\")\n}\n\n[1] \"The number is positive.\"\n\n\nIn this example, sample(-10:10, 1) generates a random number between -10 and 10, and the value is assigned to the number variable. Additionally, set.seed(42) sets the seed to 42. This ensures that when generating the random number with sample(), the same number is chosen every time the code is executed. Then, we check if the number is positive or not and print the corresponding message.\n\n\n2.1.2 else if\nIn addition to if and else, we can also use else if to add more conditions to the conditional structure. The else if allows checking multiple conditions in sequence. If the if condition is false, it checks the next else if condition. If all the if and else if conditions are false, the code block within the else is executed.\nHere is the syntax of else if:\n\nif (condition1) {\n  # Code block to execute if condition1 is true\n} else if (condition2) {\n  # Code block to execute if condition2 is true\n} else {\n  # Code block to execute if none of the previous conditions are true\n}\n\nHere is a practical example of how to use if, else if, and else to evaluate a company’s performance based on its annual revenue:\n\n# Determining the company's classification based on annual revenue\nannual_revenue &lt;- 1500000\n\nif (annual_revenue &gt;= 2000000) {\n  print(\"Large Company\")\n} else if (annual_revenue &gt;= 1000000) {\n  print(\"Medium Company\")\n} else if (annual_revenue &gt;= 500000) {\n  print(\"Small Company\")\n} else {\n  print(\"Microenterprise\")\n}\n\n[1] \"Medium Company\"\n\n\nIn this example, the company is classified based on its annual revenue. If the revenue is equal to or greater than 2,000,000, the company will be classified as a “Large Company”. If it is between 1,000,000 and 1,999,999, it will be classified as a “Medium Company”. If it is between 500,000 and 999,999, it will be classified as a “Small Company”. Otherwise, it will be considered a “Microenterprise”."
  },
  {
    "objectID": "02-fluxos.html#loop-structures",
    "href": "02-fluxos.html#loop-structures",
    "title": "2  Execution Flows",
    "section": "2.2 Loop Structures",
    "text": "2.2 Loop Structures\nLoop structures, also known as repetition structures, are used to execute a block of code repeatedly while a specific condition is true or to iterate over a sequence of elements. This is useful when you need to perform a task multiple times or want to loop through a collection of data.\n\n2.2.1 for\nOne of the most common repetition structures is the for loop. The for loop is used to iterate over a sequence of values, such as a numeric sequence of integers or the elements of a vector.\nThere are two ways to use the for loop.\n\nUsing for to iterate over indices:\n\n\n# Example of a for loop to iterate over indices\nfor (i in 1:5) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\nIn this example, the for loop iterates over the values from 1 to 5. In the first iteration, i is equal to 1; in the second iteration, i is equal to 2; and so on, until i is equal to 5.\n\nUsing for to iterate over elements:\n\n\n# Example of a for loop to iterate over elements of a vector\ncustomers &lt;- c(\"John\", \"Mary\", \"Joseph\", \"Anna\")\nfor (name in customers) {\n  print(name)\n}\n\n[1] \"John\"\n[1] \"Mary\"\n[1] \"Joseph\"\n[1] \"Anna\"\n\n\nIn the example above, the for loop iterates over the elements of the customers vector. In the first iteration, name is equal to “John”; in the second iteration, name is equal to “Mary”; and so on, until all elements of the vector are processed.\nIn both examples, the code block inside the for loop is executed repeatedly for each value of i (in the first example) or name (in the second example) until the sequence is completely traversed.\nIn the example below, let’s simulate economic data for 10 fictitious countries and calculate the per capita GDP of each country.\n\nset.seed(42)\ngdp_countries &lt;- runif(10, min = 25000000, max = 40000000)\npopulation_countries &lt;- runif(10, min = 1000000, max = 15000000)\n\ngdp_per_capita &lt;- numeric(length = 10)\n\n# For loop to calculate per capita GDP for each country\nfor (i in 1:10) {\n  # Calculating per capita GDP\n  gdp_per_capita[i] &lt;- gdp_countries[i] / population_countries[i]\n}\nprint(round(gdp_per_capita, 3))\n\n [1]  5.227  3.529  2.080  8.185  4.634  2.315  2.453 10.216  4.556  4.022\n\n\n\n\n\n\n\n\nClick to see an extra example\n\n\n\n\n\nImagine we have a time series representing the daily closing price of a stock over a period of 30 days. We want to calculate the 5-day moving average of this price, that is, for each day, we want to calculate the average of the closing prices of the five previous days, including the current day.\nFirst, let’s simulate the data for the daily closing price of the stock:\n\nset.seed(42)\nstock_price &lt;- runif(30, min = 9, max = 15)\n\nNow, let’s calculate the 5-day moving average using a for loop:\n\nmoving_average &lt;- numeric(length = 26)  # Vector to store the moving average\n\nfor (i in 5:30) {\n  moving_average[i - 4] &lt;- mean(stock_price[(i - 4):i])\n}\n\nIn this for loop, we start from the fifth day, as we need at least five days to calculate the 5-day moving average. For each day from the fifth to the thirtieth day, we calculate the average of the closing prices of the five previous days, including the current day, and store this value in the moving_average vector.\nNow we can print the calculated moving average:\n\nprint(moving_average)\n\n [1] 13.33226 12.85740 12.61682 12.43505 12.22691 12.30289 12.22926 12.20829\n [9] 13.16830 12.68642 12.39510 12.97382 13.28476 12.30414 12.56762 12.68527\n[17] 12.64209 11.63467 12.68036 13.24636 12.67289 12.20510 12.50690 12.40711\n[25] 11.80747 12.71175\n\n\nThis example demonstrates how to use a for loop in conjunction with vectors to calculate the moving average of a time series. The chart below shows the moving average over the days.\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou will learn how to build charts like this in Chapter 4.\n\n\n\n\n\n\n\n2.2.2 while\nThe while structure is used to repeat a block of code as long as a specified condition is true. Here is the general structure of a while loop:\n\nwhile (condition) {\n  # Code to be repeated while the condition is true\n}\n\nThe condition is a logical expression that is evaluated before each execution of the code block inside the loop. If the condition is true, the code block is executed; if false, the loop terminates, and control passes to the next line of code after the loop.\nIn the example below, we define a vector called actions, which contains a list of possible activities a person might perform during the day. One of the possible actions will be chosen randomly.\n\nactions &lt;- c(\"Learn to code in R\",\n             \"Learn to code in Python\",\n             \"Make coffee\",\n             \"Rest\")\n\nset.seed(42)\naction &lt;- sample(actions, 1)\nprint(action)\n\n[1] \"Learn to code in R\"\n\n\nIn the following code snippet, we use the while structure to continue randomly selecting an activity from the actions vector until the selected activity is “Rest”. The loop starts by checking if the variable action is different from “Rest”. If this condition is true, a new activity is randomly selected from the actions vector using the sample() function with size = 1. The selected activity is then printed to the screen using the print() function. This process repeats until the selected activity is “Rest”, at which point the loop ends.\n\nset.seed(420)\nwhile (action != \"Rest\") {\n  action &lt;- sample(actions, 1)\n  print(action)\n}\n\n[1] \"Learn to code in R\"\n[1] \"Learn to code in R\"\n[1] \"Learn to code in Python\"\n[1] \"Learn to code in Python\"\n[1] \"Rest\"\n\n\n\n\n\n\n\n\nClick to see an additional example\n\n\n\n\n\nLet’s consider an example where we want to simulate population growth over time, where the number of periods required to reach a certain limit is unknown. In this case, we use a while loop to simulate population growth until the population reaches a set threshold.\n\nset.seed(42)  # Set seed for reproducibility\n\n# Initial population\npopulation &lt;- 1000\n\n# Annual population growth rate (in decimal)\ngrowth_rate &lt;- 0.02\n\n# Desired population limit\npopulation_limit &lt;- 2000\n\n# Initialize year counter\nyears &lt;- 0\n\n# Simulating population growth until the limit is reached\nwhile (population &lt; population_limit) {\n  # Calculate new individuals this year\n  new_individuals &lt;- population * growth_rate\n  \n  # Increment population with new individuals\n  population &lt;- population + new_individuals\n  \n  # Increment year counter\n  years &lt;- years + 1\n}\n\n# Print the number of years required to reach the population limit\nprint(paste(\"It took\", years, \"years to reach a population of\", population))\n\n[1] \"It took 36 years to reach a population of 2039.8873437157\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou can calculate the exact number of years needed to reach the population limit directly. Using algebra, the formula is as follows:\n\\[\\text{years} = \\frac{\\log\\left(\\frac{\\text{population\\_limit}}{\\text{initial\\_population}}\\right)}{\\log(1 + \\text{growth\\_rate})}.\\]"
  },
  {
    "objectID": "02-fluxos.html#sec-fluxos-functions",
    "href": "02-fluxos.html#sec-fluxos-functions",
    "title": "2  Execution Flows",
    "section": "2.3 Functions",
    "text": "2.3 Functions\nA function in R is a block of code that performs a specific task and can be reused multiple times. The syntax for defining a function in R follows this pattern:\n\nfunction_name &lt;- function(parameters) {\n  # Function body\n  # Code that performs the desired task\n  # May include mathematical operations, data manipulation, etc.\n  return(result)  # Returns the desired result\n}\n\nParameters are variables that a function takes as input to perform its operations. They are specified within parentheses when defining the function. Inside the function body, these parameters can be used to perform calculations or operations.\nThe example below defines a function to perform a simple linear regression. The linear_regression function takes two parameters: x and y, which represent the input data for the regression. Inside the function, a linear regression model is created using the lm() function in R, with y as a function of x. The model is then returned as the function result.\n\n# Function to perform simple linear regression\nlinear_regression &lt;- function(x, y) {\n  model &lt;- lm(y ~ x)  # Creating the linear regression model\n  return(model)  # Returning the model\n}\n\n# Example data: salary (y) as a function of years of education (x)\neducation_years &lt;- c(10, 12, 14, 16, 18)\nsalary &lt;- c(2500, 3300, 3550, 3700, 4500)\n\n# Calling the linear regression function\nregression_model &lt;- linear_regression(education_years, salary)\n\nDisplay the summary of the trained model:\n\n# Display regression results\nsummary(regression_model)\n\n\nCall:\nlm(formula = y ~ x)\n\nResiduals:\n   1    2    3    4    5 \n-130  230   40 -250  110 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)   \n(Intercept)   430.00     498.20   0.863  0.45156   \nx             220.00      34.88   6.307  0.00805 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 220.6 on 3 degrees of freedom\nMultiple R-squared:  0.9299,    Adjusted R-squared:  0.9065 \nF-statistic: 39.78 on 1 and 3 DF,  p-value: 0.008054\n\n\nBelow is a scatter plot showing the relationship between years of education and salary. The blue line represents the linear regression model trained on the data.\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou will learn how to build charts like this in Chapter 4."
  },
  {
    "objectID": "02-fluxos.html#sec-packages",
    "href": "02-fluxos.html#sec-packages",
    "title": "2  Execution Flows",
    "section": "2.4 Packages",
    "text": "2.4 Packages\nPackages in R are collections of functions, datasets, and documentation that extend the core capabilities of the R language. They are essential for performing a wide variety of tasks.\nR packages are available on CRAN (Comprehensive R Archive Network), a centralized repository that hosts a vast collection of packages. To access CRAN packages, use the install.packages() function. For example:\n\ninstall.packages(\"package_name\")\n\nAfter installation, load the package into your R session using the library() function:\n\nlibrary(package_name)\n\nThis makes the package’s functions and datasets available for use in your current session."
  },
  {
    "objectID": "02-fluxos.html#exercises",
    "href": "02-fluxos.html#exercises",
    "title": "2  Execution Flows",
    "section": "2.5 Exercises",
    "text": "2.5 Exercises\n1. In this exercise, simulate a coin toss and store the results as a factor with levels “heads” and “tails”. Follow these steps:\na) Use the command below to generate random samples following a binomial distribution to simulate 100 coin tosses:\n\nset.seed(42)\ntosses &lt;- rbinom(100, 1, 0.5)\n\nb) Assume 0 represents “heads” and 1 represents “tails”. Create a variable to store the tosses as a factor with levels “heads” and “tails”.\nc) Count how many times each result occurred in this experiment.\nd) Use a loop to iterate backward through the vector and find the last “heads” result.\n2. Working with package datasets.\na) Install the nycflights13 package:\n\ninstall.packages(\"nycflights13\")\n\nb) Load the package into your environment:\n\nlibrary(nycflights13)\n\nc) Use the commands below to explore the contents of the flights and airports data frames:\n\n?flights\n?airports\n\nd) Filter the flights that occurred on 12/25/2013 and store them in the variable christmas.\ne) How many flights departed from New York on 12/25/2013?\nf) Get a summary of the dep_delay column. Are there missing values? If yes, remove them.\ng) Find the name of the destination airport of the flight with the longest departure delay on 12/25/2013. Hint: Merge the flights and airports datasets."
  },
  {
    "objectID": "03-dados.html#importing-external-files",
    "href": "03-dados.html#importing-external-files",
    "title": "3  Data Manipulation",
    "section": "3.1 Importing External Files",
    "text": "3.1 Importing External Files\nTwo of the most common formats for storing not-so-large datasets are csv and xlsx.\nWhen loading data from CSV files in R, two commonly used options are the read.csv() and read_csv() functions. Both are effective for importing tabular data but have significant differences. The read.csv() function is a standard option in base R, being simple to use and widely known. On the other hand, read_csv() is part of the readr package, offering optimized performance and automatic data type detection. While read.csv() tends to be slower, especially with large datasets, read_csv() is faster and more accurate, capable of maintaining column names as symbols and properly handling data, including empty strings.\n\n# Using read.csv()\ndata_read_csv &lt;- read.csv(\"data.csv\")\n\n# Using read_csv() from the readr package\nlibrary(readr)\ndata_readr &lt;- read_csv(\"data.csv\")\n\nTo import data from an Excel file (xlsx format) in R, we can use the readxl library. First, you need to install it using the command install.packages(\"readxl\"). Then, you can use the read_excel() function to read the data. For example:\n\nlibrary(readxl)\ndata &lt;- read_excel(\"file.xlsx\")\n\n\n\n\n\n\n\nSetting Your Working Directory\n\n\n\nIt is good practice to set a working directory in your R scripts because it helps keep things organized and makes it easier to access data files and results. By setting a working directory, you ensure that all files referenced in your scripts will be easily found without needing to specify long absolute paths.\nTo set the working directory in R, you can use the setwd() function. For example, if you want to set the directory to “C:/MyDirectory”, you can do the following:\n\nsetwd(\"C:/MyDirectory\")\n\nYou can also set the directory using the RStudio interface. Simply select “Session” from the menu, then “Set Working Directory,” and finally “Choose Directory.” This will open a dialog box where you can navigate to the desired directory and select it. After selecting the directory, it will become the current working directory."
  },
  {
    "objectID": "03-dados.html#the-tidyverse-package",
    "href": "03-dados.html#the-tidyverse-package",
    "title": "3  Data Manipulation",
    "section": "3.2 The tidyverse Package",
    "text": "3.2 The tidyverse Package\nThe tidyverse package is a collection of R packages designed to work seamlessly and intuitively for data analysis. It includes a variety of powerful and popular packages such as ggplot2, dplyr, tidyr, tibble, readr, purrr, forcats, and stringr. Each package in the tidyverse is designed to handle a specific step of the data analysis workflow, from importing and cleaning to visualization and modeling. All packages in the tidyverse share a common underlying design philosophy, grammar, and data structures. Learn more on the package page."
  },
  {
    "objectID": "03-dados.html#the-pipe-operator",
    "href": "03-dados.html#the-pipe-operator",
    "title": "3  Data Manipulation",
    "section": "3.3 The |> Pipe Operator",
    "text": "3.3 The |&gt; Pipe Operator\nThe |&gt; operator, known as the pipe, is a powerful tool in R that facilitates chaining operations in sequence. It allows you to write code more clearly and concisely, especially when working with tidyverse packages. The pipe takes the result of an expression on the left and passes it as the first argument to the next expression on the right.\n\n\n\n\n\n\nTip\n\n\n\nYou don’t need to type |&gt; every time you need it. Use the shortcut Ctrl+Shift+M.\n\n\nSuppose we have a function f, a function g, and a variable x. We want to apply g to x, and then apply f to the result. Here’s how we could do this in two ways: using the traditional chained approach and using the |&gt; pipe.\n\nresult &lt;- f(g(x))\n\nx |&gt; \n  g() |&gt;\n  f()\n\nBoth methods will produce the same result. However, the second approach using the |&gt; pipe is more readable and easier to understand, especially when chaining multiple operations. This makes the code more concise and closer to a natural reading of the operation being performed.\n\n\n\n\n\n\nTip\n\n\n\nA good practice when using the |&gt; pipe is to break the line after each pipe to improve code readability."
  },
  {
    "objectID": "03-dados.html#data-in-tidy-format",
    "href": "03-dados.html#data-in-tidy-format",
    "title": "3  Data Manipulation",
    "section": "3.4 Data in Tidy Format",
    "text": "3.4 Data in Tidy Format\n\n“Tidy datasets are all alike, but every messy dataset is messy in its own way.” — Hadley Wickham.\n\nThe same dataset can be represented in various ways. See the code below that shows the same data in three different formats.\n\ntable1\n\n# A tibble: 6 × 4\n  country      year  cases population\n  &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n\ntable2\n\n# A tibble: 12 × 4\n   country      year type            count\n   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n\ntable4a\n\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n\n\nAll of the above representations are of the same data, but they are not equally easy to use. table1, for example, will be much more accessible for working within the tidyverse due to its organization in the tidy format. There are three interrelated rules that characterize a dataset in tidy format:\n\nEach variable is a column; each column represents a variable.\nEach observation is a row; each row represents an observation.\nEach value is a cell; each cell contains a single value.\n\nThe figure below graphically represents this concept.\n\n\n\nImage from the R4DS book.\n\n\nPivoting data is the process of reorganizing a dataset to make it compatible with the tidy format. This involves transforming the data from a wider format to a longer format, or vice versa, to ensure that each variable corresponds to a column and each observation to a row.\nIn the example below, we are transforming the data from table2 to a wider format, where each unique value of the variable type becomes a new column. Note that each unit of information (country, year, cases, and count) is split into two rows. This operation makes the data table wider, ensuring that each unit of data is represented in a single row.\n\ntable2 |&gt; \n  pivot_wider(names_from=\"type\", values_from=\"count\")\n\n# A tibble: 6 × 4\n  country      year  cases population\n  &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n\n\nIn the example below, we are transforming the data from table4a to a longer format, where the columns representing specific years (1999 and 2000) are gathered into a single column called year, and the corresponding values are placed in a new column called cases. In this case, the information about years was stored as column names, but according to the tidy data principle, they should be in columns. Therefore, we use the pivot_longer function.\n\ntable4a |&gt; \n  pivot_longer(cols = c(`1999`, `2000`), names_to = \"year\", values_to = \"cases\")\n\n# A tibble: 6 × 3\n  country     year   cases\n  &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n\n\nThe two functions pivot_wider and pivot_longer are sufficient for transforming datasets into tidy format."
  },
  {
    "objectID": "03-dados.html#main-verbs-of-the-dplyr-package",
    "href": "03-dados.html#main-verbs-of-the-dplyr-package",
    "title": "3  Data Manipulation",
    "section": "3.5 Main Verbs of the dplyr Package",
    "text": "3.5 Main Verbs of the dplyr Package\nThe dplyr package is one of the most powerful tools for data manipulation in the R environment. It offers a cohesive set of functions that simplify common manipulation tasks such as filtering, selecting, grouping, sorting, and summarizing data. dplyr uses an intuitive and consistent syntax, making it easy to write clean and readable code.\nLet’s study the functionality of the main verbs of the package. To illustrate, we will use the gapminder dataset. It is a collection of socioeconomic information for various countries over time. See Rosling (2012). It includes variables such as life expectancy, GDP per capita, infant mortality rate, and population size for different countries and years, covering several decades.\nTo load the gapminder dataset, you need to load the gapminder package. With the gapminder package loaded, the gapminder dataset will be available for use in your R environment:\n\nlibrary(gapminder)\n\nWarning: package 'gapminder' was built under R version 4.2.3\n\nhead(gapminder)\n\nThe glimpse() function provides a quick and concise overview of the structure of a dataset. When applied to a dataset, like gapminder, it displays essential information about the variables present, including the number of rows, columns, and the first few rows of the dataset:\n\nglimpse(gapminder)\n\nRows: 1,704\nColumns: 6\n$ country   &lt;fct&gt; \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", …\n$ continent &lt;fct&gt; Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, …\n$ year      &lt;int&gt; 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, …\n$ lifeExp   &lt;dbl&gt; 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8…\n$ pop       &lt;int&gt; 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12…\n$ gdpPercap &lt;dbl&gt; 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, 786.1134, …\n\n\n\n3.5.1 select\nThe select() verb is used to select specific columns from a dataset. With select(), you can choose the desired columns based on their names, data types, or other criteria.\nFor example, considering the gapminder dataset, suppose we want to select only the columns referring to the year, country, life expectancy, and GDP per capita. We can do this as follows:\n\n# Selecting columns by name\ngapminder |&gt;\n  select(year, country, lifeExp, gdpPercap)\n\n# Selecting only numeric columns\ngapminder |&gt; \n  select(where(is.numeric))\n\n# Selecting columns that start with \"co\"\ngapminder |&gt; \n  select(starts_with(\"co\"))\n\nNote that in the above examples, none of the selections was saved to a variable. To save the selections to a variable, you can assign the result of each select() operation to a separate variable. For example:\n\ngapminder_character &lt;- gapminder |&gt; \n  select(where(is.character))\n\n\n\n3.5.2 arrange\nThe verb arrange() is used to reorder the rows of a dataset based on the values of one or more columns. When applied to a dataset, arrange() sorts the rows in ascending or descending order based on the specified column values.\nIn the first example using the verb select(), we can sort the data by country in alphabetical order as follows:\n\ngapminder |&gt;\n  select(year, country, lifeExp, gdpPercap, pop) |&gt;\n  arrange(country)\n\n# A tibble: 1,704 × 5\n    year country     lifeExp gdpPercap      pop\n   &lt;int&gt; &lt;fct&gt;         &lt;dbl&gt;     &lt;dbl&gt;    &lt;int&gt;\n 1  1952 Afghanistan    28.8      779.  8425333\n 2  1957 Afghanistan    30.3      821.  9240934\n 3  1962 Afghanistan    32.0      853. 10267083\n 4  1967 Afghanistan    34.0      836. 11537966\n 5  1972 Afghanistan    36.1      740. 13079460\n 6  1977 Afghanistan    38.4      786. 14880372\n 7  1982 Afghanistan    39.9      978. 12881816\n 8  1987 Afghanistan    40.8      852. 13867957\n 9  1992 Afghanistan    41.7      649. 16317921\n10  1997 Afghanistan    41.8      635. 22227415\n# ℹ 1,694 more rows\n\n\nIn the example below, we are organizing the data by year in ascending order and life expectancy in descending order within each year.\n\ngapminder |&gt;\n  select(year, country, lifeExp, gdpPercap, pop) |&gt;\n  arrange(year, desc(lifeExp))\n\n# A tibble: 1,704 × 5\n    year country        lifeExp gdpPercap      pop\n   &lt;int&gt; &lt;fct&gt;            &lt;dbl&gt;     &lt;dbl&gt;    &lt;int&gt;\n 1  1952 Norway            72.7    10095.  3327728\n 2  1952 Iceland           72.5     7268.   147962\n 3  1952 Netherlands       72.1     8942. 10381988\n 4  1952 Sweden            71.9     8528.  7124673\n 5  1952 Denmark           70.8     9692.  4334000\n 6  1952 Switzerland       69.6    14734.  4815000\n 7  1952 New Zealand       69.4    10557.  1994794\n 8  1952 United Kingdom    69.2     9980. 50430000\n 9  1952 Australia         69.1    10040.  8691212\n10  1952 Canada            68.8    11367. 14785584\n# ℹ 1,694 more rows\n\n\n\n\n\n\n\n\nTip\n\n\n\nWhen using the verb select() with the prefix -, you can specify the columns you want to exclude from the dataset. In the example below, we exclude the continent column from the selection.\n\ngapminder |&gt; \n  select(-continent)\n\n# A tibble: 1,704 × 5\n   country      year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan  1952    28.8  8425333      779.\n 2 Afghanistan  1957    30.3  9240934      821.\n 3 Afghanistan  1962    32.0 10267083      853.\n 4 Afghanistan  1967    34.0 11537966      836.\n 5 Afghanistan  1972    36.1 13079460      740.\n 6 Afghanistan  1977    38.4 14880372      786.\n 7 Afghanistan  1982    39.9 12881816      978.\n 8 Afghanistan  1987    40.8 13867957      852.\n 9 Afghanistan  1992    41.7 16317921      649.\n10 Afghanistan  1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n\n\n\n\n3.5.3 filter\nTo analyze specific data of interest, it is often necessary to filter the dataset to include only relevant observations. The verb filter() is used for this purpose. Simply define one or more logical conditions that the rows of the dataset must satisfy to be displayed.\nIn the example below, we filter the data to include only observations where the country is either Brazil or Argentina.\n\ngapminder |&gt;\n  select(year, country, lifeExp, gdpPercap, pop) |&gt;\n  arrange(year, desc(lifeExp)) |&gt; \n  filter(country == \"Brazil\" | country == \"Argentina\")\n\n# A tibble: 24 × 5\n    year country   lifeExp gdpPercap       pop\n   &lt;int&gt; &lt;fct&gt;       &lt;dbl&gt;     &lt;dbl&gt;     &lt;int&gt;\n 1  1952 Argentina    62.5     5911.  17876956\n 2  1952 Brazil       50.9     2109.  56602560\n 3  1957 Argentina    64.4     6857.  19610538\n 4  1957 Brazil       53.3     2487.  65551171\n 5  1962 Argentina    65.1     7133.  21283783\n 6  1962 Brazil       55.7     3337.  76039390\n 7  1967 Argentina    65.6     8053.  22934225\n 8  1967 Brazil       57.6     3430.  88049823\n 9  1972 Argentina    67.1     9443.  24779799\n10  1972 Brazil       59.5     4986. 100840058\n# ℹ 14 more rows\n\n\n\n\n3.5.4 mutate\nThe verb mutate() is used to create or modify columns in an existing dataset. It allows adding new variables calculated based on existing variables or modifying existing variables according to specific logic.\nFor example, we can use mutate() to calculate a new variable representing the total GDP of each country by multiplying per capita GDP by population size. Here’s an example of how to do this with the gapminder dataset:\n\ngapminder_total_gdp &lt;- gapminder |&gt;\n  select(country, year, lifeExp, gdpPercap, pop) |&gt;\n  mutate(total_gdp = gdpPercap * pop)\n\n\n\n3.5.5 summarise\nThe verb summarise() is used to summarize data into a single row, usually by calculating summary statistics such as mean, sum, median, etc. It allows calculating statistical summaries in a dataset, creating a new table containing the summarized results.\nHere is an example of how to use summarise() to calculate the average life expectancy using the gapminder dataset:\n\ngapminder |&gt;\n  summarise(mean_lifeExp = mean(lifeExp, na.rm = TRUE))\n\n# A tibble: 1 × 1\n  mean_lifeExp\n         &lt;dbl&gt;\n1         59.5\n\n\n\n\n3.5.6 group by\nThe verb group_by() is used to split data into groups based on the values of one or more variables. It does not perform calculations by itself but changes the behavior of summary functions, such as summarise(), to operate separately on each group.\nHere is an example of how to use group_by() with the gapminder data to calculate the average life expectancy by continent:\n\ngapminder |&gt;\n  group_by(continent) |&gt;\n  summarise(mean_lifeExp = mean(lifeExp, na.rm = TRUE))\n\n# A tibble: 5 × 2\n  continent mean_lifeExp\n  &lt;fct&gt;            &lt;dbl&gt;\n1 Africa            48.9\n2 Americas          64.7\n3 Asia              60.1\n4 Europe            71.9\n5 Oceania           74.3\n\n\nThe example below uses all the main verbs of dplyr to calculate the average life expectancy and the average GDP (in thousands) by continent in the year 2007.\n\ngapminder |&gt;\n  select(country, continent, year, lifeExp, gdpPercap) |&gt; \n  filter(year == 2007) |&gt; # data only for the year 2007\n  mutate(gdp = gdpPercap / 1000) |&gt; # represents per capita GDP in thousands\n  group_by(continent) |&gt; # group the data by continent\n  summarise(mean_lifeExp = mean(lifeExp, na.rm = TRUE), # average life expectancy\n            mean_gdp = mean(gdp, na.rm = TRUE)) |&gt; # average per capita GDP in billions\n  arrange(desc(mean_lifeExp))\n\n# A tibble: 5 × 3\n  continent mean_lifeExp mean_gdp\n  &lt;fct&gt;            &lt;dbl&gt;    &lt;dbl&gt;\n1 Oceania           80.7    29.8 \n2 Europe            77.6    25.1 \n3 Americas          73.6    11.0 \n4 Asia              70.7    12.5 \n5 Africa            54.8     3.09\n\n\nThe graph below shows the evolution of average life expectancy in the continents over the years.\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWhat change was made to the code of the previous example to construct the data used in this graph?"
  },
  {
    "objectID": "03-dados.html#helper-functions",
    "href": "03-dados.html#helper-functions",
    "title": "3  Data Manipulation",
    "section": "3.6 Helper Functions",
    "text": "3.6 Helper Functions\nIntroducing auxiliary functions from the dplyr package that can be very useful in various contexts.\n\npull, distinct, unite, separate_wider_delim, and the family of slice_* functions.\n\n\ngapminder |&gt; \n  filter(year == 1952) |&gt; \n  pull(continent)\n\n  [1] Asia     Europe   Africa   Africa   Americas Oceania  Europe   Asia    \n  [9] Asia     Europe   Africa   Americas Europe   Africa   Americas Europe  \n [17] Africa   Africa   Asia     Africa   Americas Africa   Africa   Americas\n [25] Asia     Americas Africa   Africa   Africa   Americas Africa   Europe  \n [33] Americas Europe   Europe   Africa   Americas Americas Africa   Americas\n [41] Africa   Africa   Africa   Europe   Europe   Africa   Africa   Europe  \n [49] Africa   Europe   Americas Africa   Africa   Americas Americas Asia    \n [57] Europe   Europe   Asia     Asia     Asia     Asia     Europe   Asia    \n [65] Europe   Americas Asia     Asia     Africa   Asia     Asia     Asia    \n [73] Asia     Africa   Africa   Africa   Africa   Africa   Asia     Africa  \n [81] Africa   Africa   Americas Asia     Europe   Africa   Africa   Asia    \n [89] Africa   Asia     Europe   Oceania  Americas Africa   Africa   Europe  \n [97] Asia     Asia     Americas Americas Americas Asia     Europe   Europe  \n[105] Americas Africa   Europe   Africa   Africa   Asia     Africa   Europe  \n[113] Africa   Asia     Europe   Europe   Africa   Africa   Europe   Asia    \n[121] Africa   Africa   Europe   Europe   Asia     Asia     Africa   Asia    \n[129] Africa   Americas Africa   Europe   Africa   Europe   Americas Americas\n[137] Americas Asia     Asia     Asia     Africa   Africa  \nLevels: Africa Americas Asia Europe Oceania\n\ngapminder |&gt; \n  distinct(continent)\n\n# A tibble: 5 × 1\n  continent\n  &lt;fct&gt;    \n1 Asia     \n2 Europe   \n3 Africa   \n4 Americas \n5 Oceania  \n\ngapminder |&gt; \n  slice(1:10)\n\n# A tibble: 10 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n\ngapminder |&gt; \n  slice_head(n = 5)\n\n# A tibble: 5 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n\ngapminder |&gt; \n  slice_tail(n = 5)\n\n# A tibble: 5 × 6\n  country  continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;    &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Zimbabwe Africa     1987    62.4  9216418      706.\n2 Zimbabwe Africa     1992    60.4 10704340      693.\n3 Zimbabwe Africa     1997    46.8 11404948      792.\n4 Zimbabwe Africa     2002    40.0 11926563      672.\n5 Zimbabwe Africa     2007    43.5 12311143      470.\n\nset.seed(1)\ngapminder |&gt; \n  slice_sample(n = 10)\n\n# A tibble: 10 × 6\n   country     continent  year lifeExp        pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;      &lt;int&gt;     &lt;dbl&gt;\n 1 Montenegro  Europe     1992    75.4     621621     7003.\n 2 Hungary     Europe     1982    69.4   10705535    12546.\n 3 Benin       Africa     1992    53.9    4981671     1191.\n 4 Malawi      Africa     1977    43.8    5637246      663.\n 5 Thailand    Asia       1992    67.3   56667095     4617.\n 6 El Salvador Americas   1962    52.3    2747687     3777.\n 7 China       Asia       2002    72.0 1280400000     3119.\n 8 Chad        Africa     1977    47.4    4388260     1134.\n 9 Peru        Americas   2002    69.9   26769436     5909.\n10 Senegal     Africa     2002    61.6   10870037     1520.\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  slice_max(lifeExp, n = 2)\n\n# A tibble: 2 × 6\n  country          continent  year lifeExp       pop gdpPercap\n  &lt;fct&gt;            &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n1 Japan            Asia       2007    82.6 127467972    31656.\n2 Hong Kong, China Asia       2007    82.2   6980412    39725.\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  slice_min(lifeExp, n = 2)\n\n# A tibble: 2 × 6\n  country    continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;      &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Swaziland  Africa     2007    39.6  1133066     4513.\n2 Mozambique Africa     2007    42.1 19951656      824.\n\ngapminder |&gt; \n  filter(year == 2007 | year == 1952) |&gt; \n  group_by(year) |&gt; \n  slice_max(lifeExp, n = 2)\n\n# A tibble: 4 × 6\n# Groups:   year [2]\n  country          continent  year lifeExp       pop gdpPercap\n  &lt;fct&gt;            &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n1 Norway           Europe     1952    72.7   3327728    10095.\n2 Iceland          Europe     1952    72.5    147962     7268.\n3 Japan            Asia       2007    82.6 127467972    31656.\n4 Hong Kong, China Asia       2007    82.2   6980412    39725.\n\ngapminder_united &lt;- gapminder |&gt; \n  unite(\"country_continent\", c(country, continent),\n        sep = \"_\",\n        remove = TRUE,\n        na.rm = FALSE)\n\ngapminder_united |&gt;\n  separate_wider_delim(country_continent,\n                       delim = \"_\",\n                       names = c(\"country\", \"continent\"))\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;chr&gt;       &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows"
  },
  {
    "objectID": "03-dados.html#sec-ex-dados",
    "href": "03-dados.html#sec-ex-dados",
    "title": "3  Data Manipulation",
    "section": "3.7 Exercises",
    "text": "3.7 Exercises\nLet’s work with the billboard dataset. In this dataset, each observation is a song. The first three columns (artist, track, and date entered) are variables that describe the song. Then, we have 76 columns (wk1-wk76) that describe the song’s ranking each week. Here, the column names are a variable (the week), and the cell values are another (the ranking).\n\nlibrary(tidyverse)\nbillboard\n\n# A tibble: 317 × 79\n   artist     track date.entered   wk1   wk2   wk3   wk4   wk5   wk6   wk7   wk8\n   &lt;chr&gt;      &lt;chr&gt; &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 2 Pac      Baby… 2000-02-26      87    82    72    77    87    94    99    NA\n 2 2Ge+her    The … 2000-09-02      91    87    92    NA    NA    NA    NA    NA\n 3 3 Doors D… Kryp… 2000-04-08      81    70    68    67    66    57    54    53\n 4 3 Doors D… Loser 2000-10-21      76    76    72    69    67    65    55    59\n 5 504 Boyz   Wobb… 2000-04-15      57    34    25    17    17    31    36    49\n 6 98^0       Give… 2000-08-19      51    39    34    26    26    19     2     2\n 7 A*Teens    Danc… 2000-07-08      97    97    96    95   100    NA    NA    NA\n 8 Aaliyah    I Do… 2000-01-29      84    62    51    41    38    35    35    38\n 9 Aaliyah    Try … 2000-03-18      59    53    38    28    21    18    16    14\n10 Adams, Yo… Open… 2000-08-26      76    76    74    69    68    67    61    58\n# ℹ 307 more rows\n# ℹ 68 more variables: wk9 &lt;dbl&gt;, wk10 &lt;dbl&gt;, wk11 &lt;dbl&gt;, wk12 &lt;dbl&gt;,\n#   wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;, wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, wk17 &lt;dbl&gt;, wk18 &lt;dbl&gt;,\n#   wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, wk22 &lt;dbl&gt;, wk23 &lt;dbl&gt;, wk24 &lt;dbl&gt;,\n#   wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, wk27 &lt;dbl&gt;, wk28 &lt;dbl&gt;, wk29 &lt;dbl&gt;, wk30 &lt;dbl&gt;,\n#   wk31 &lt;dbl&gt;, wk32 &lt;dbl&gt;, wk33 &lt;dbl&gt;, wk34 &lt;dbl&gt;, wk35 &lt;dbl&gt;, wk36 &lt;dbl&gt;,\n#   wk37 &lt;dbl&gt;, wk38 &lt;dbl&gt;, wk39 &lt;dbl&gt;, wk40 &lt;dbl&gt;, wk41 &lt;dbl&gt;, wk42 &lt;dbl&gt;, …\n\n\na) Apply a transformation to the dataset to leave it in the format below.\n\n\n# A tibble: 24,092 × 5\n   artist track                   date.entered week   rank\n   &lt;chr&gt;  &lt;chr&gt;                   &lt;date&gt;       &lt;chr&gt; &lt;dbl&gt;\n 1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87\n 2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82\n 3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72\n 4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77\n 5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87\n 6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94\n 7 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk7      99\n 8 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk8      NA\n 9 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk9      NA\n10 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk10     NA\n# ℹ 24,082 more rows\n\n\nb) Observe the result of item a). What happens if a song is in the top 100 for less than 76 weeks? Take the song “Baby Don’t Cry” by 2 Pac, for example. The output above suggests that it was in the top 100 for only 7 weeks, and all remaining weeks are filled with missing values (NA). These NAs actually do not represent unknown observations; they were forced to exist by the structure of the dataset. Change the code used in a) to remove these NAs. Answer: How many rows are left? (Hint: see the documentation of the pivot_longer function.)\nc) You may have noticed that in the result of item a), the type of the week column is character. Perform the appropriate transformation to obtain a column with numerical values.\nd) Which song stayed in the top 100 of the Billboard in 2000 for the most weeks? How many weeks did this song appear in the ranking? And which song stayed in the ranking for the least time?\ne) Which song stayed exactly 10 weeks in the top 100 of the Billboard in 2000? If there is more than one song in this condition, consider the one that first entered the ranking.\n\n\n\n\nRosling, Hans. 2012. “Data - Gapminder.org.” http://www.gapminder.org/data/."
  },
  {
    "objectID": "04-visualizacao.html#grammar-of-graphics",
    "href": "04-visualizacao.html#grammar-of-graphics",
    "title": "4  Data Visualization",
    "section": "4.1 Grammar of Graphics",
    "text": "4.1 Grammar of Graphics\nIt is based on the grammar of graphics (grammar of graphics - GG), see Wilkinson (2012). The grammar of graphics is a set of principles and concepts that describe the structure and rules for creating charts consistently and effectively. GG is a framework for data visualization that breaks down each component of a chart into individual elements, creating distinct layers. Using the GG system, we can build charts step by step to achieve flexible and customizable results. Each aspect of the chart, such as points, lines, colors, and scales, is treated as a separate piece, allowing detailed control over the appearance and content of the final chart.\n\n\n\nFigure from Wilkinson (2012)."
  },
  {
    "objectID": "04-visualizacao.html#the-ggplot-package",
    "href": "04-visualizacao.html#the-ggplot-package",
    "title": "4  Data Visualization",
    "section": "4.2 The ggplot Package",
    "text": "4.2 The ggplot Package\nThe most well-known data visualization package in R is ggplot2, which is based on the grammar of graphics. ggplot2 allows the creation of a wide variety of charts, including scatter plots, line plots, bar charts, histograms, and more, in a simple and flexible way. With ggplot2, you can customize basicaly all aspects of the chart, from the shape and color of the points to the axis scales and the background appearance.\nTo exemplify the use of ggplot, let’s consider the gapminder dataset, Rosling (2012).\n\n4.2.1 Data\nThe ggplot() function initializes a ggplot2 chart and defines the data to be used.\n\nlibrary(tidyverse)\nlibrary(gapminder)\n\ngapminder_2007 &lt;- gapminder %&gt;% \n  filter(year == 2007)\n\nggplot(data = gapminder_2007)\n\n\n\n\n\n\n\n\n\n\nThe generated plot is also not wrong!\n\n\n\nThis code creates a chart using the gapminder data for the year 2007 only. That’s all. There are no extra instructions about what to display on each axis (chart aesthetics).\n\n\n\n\n4.2.2 Aesthetics\nThe aesthetic mapping (aes) in ggplot2 is a function that allows linking variables from a dataset to the visual properties of a chart, such as color, shape, size, and position. Through aesthetic mapping, we can control how the data is visually represented in the chart.\nFor example, when creating a scatter plot, we can map the x (horizontal) variable and the y (vertical) variable from the dataset to the chart coordinates.\n\nggplot(data = gapminder_2007, \n       mapping = aes(x = gdpPercap, y = lifeExp))\n\n\n\n\n\n\n\n\n\n\nThe generated plot is also not wrong!\n\n\n\nThis code defines a scatter plot using the gapminder data for the year 2007 only. The x-axis represents GDP per capita (gdpPercap), and the y-axis represents life expectancy (lifeExp). That’s all. There are no extra instructions in the code snippet about the format (geometry) that should be used to display the data.\n\n\n\n\n4.2.3 Geometry\nGeometry refers to the visual elements that make up a chart, such as points, lines, bars, and areas. Each chart type has its corresponding geometry, specified by the geom_* function followed by the desired geometry type.\nFor example, to create a scatter plot, we use the geom_point() geometry, while for creating a bar chart, we use the geom_bar() geometry.\n\nggplot(data = gapminder_2007, \n       mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()\n\n\n\n\nEach geometry has its specific parameters that can be adjusted to customize the appearance of the chart, such as color, size, fill, and transparency.\n\n\n\n\n\n\nAdding color aesthetics to the chart\n\n\n\nTo color each point in the scatter plot according to the continent, just add color = continent to the aesthetic mapping.\n\nggplot(data = gapminder_2007, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point()\n\n\n\n\n\n\n\n4.2.3.1 Other Geometries\nBelow are examples of other possible geometries. Some changes were made to how the ggplot functions are used. Purposefully, no descriptive text was added as these changes should be easy to interpret.\ngeom_line():\n\n# Filter data for Brazil\ndados_pais &lt;- gapminder %&gt;%\n  filter(country == \"Brazil\")\n\n# Create line plot\nggplot(data = gapminder %&gt;%\n         filter(country == \"Brazil\"), \n       aes(x = year, y = lifeExp)) +\n  geom_line()\n\n\n\n\ngeom_bar():\n\n# Create bar plot\nggplot(data = gapminder_2007, aes(x = continent, y = gdpPercap)) +\n  geom_bar(stat = \"summary\", fun = \"mean\")\n\n\n\n\ngeom_boxplot():\n\nggplot(data = gapminder_2007, aes(x = continent, y = lifeExp)) +\n  geom_boxplot()\n\n\n\n\ngeom_text():\n\ngapminder_2007 %&gt;% \n  group_by(continent) %&gt;% \n  summarise(mean_lifeExp = mean(lifeExp),\n            mean_gdpPercap = mean(gdpPercap)) %&gt;% \n  ggplot(aes(x = mean_gdpPercap, y = mean_lifeExp, label = continent)) +\n  geom_point() +\n  geom_text(vjust = -0.5, hjust = 0.5)\n\n\n\n\nNote that we are combining two geometries in a single plot (point and text). Text labels are added to points using the geom_text() geometry, with the parameters vjust and hjust defining the vertical and horizontal position of the text, respectively:\n\nThe vjust parameter adjusts the vertical alignment of the text relative to the point. A negative value (-0.5, for example) moves the text above the point, while a positive value moves it below the point.\nThe hjust parameter adjusts the horizontal alignment of the text relative to the point. A value of 0.5 centers the text horizontally relative to the point.\n\n\n\n\n4.2.4 Facets\nFacets refer to the ability to split a plot into multiple visualizations based on one or more categorical variables. This allows comparing relationships between variables in different data segments.\nFacets are added using the facet_wrap() function to create a matrix of panels based on a categorical variable or facet_grid() to create a panel grid based on two categorical variables.\nFor example, we can use facets to create separate scatter plots for two distinct years, allowing comparisons of the relationships between GDP per capita and life expectancy in those two years.\n\ngapminder_anos &lt;- gapminder %&gt;% \n  filter(year == 1952 | year == 2007)\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~year)\n\n\n\n\n\n\n4.2.5 Coordinates\nCoordinates in ggplot2 determine how data is mapped in a graphic space. This includes the scales of the x and y axes, as well as any transformation or adjustment applied to the data. Coordinates affect the overall appearance of the chart, including its orientation, proportion, and scale.\nTo set limits on the x and y axes, we can use the coord_cartesian() function to control which value ranges are displayed on the chart. This is useful when we want to focus on a specific part of the data or prevent outliers from influencing the axis scales.\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~year) +\n  coord_cartesian(ylim = c(40, 83))\n\n\n\n\nIt is possible to apply a logarithmic scale to the axes as well. This is useful when the data has a wide range of values and we are interested in highlighting differences across a broad range of values, such as in income or GDP data. To do this, simply use the scale_*_log10() function:\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~year) +\n  scale_x_log10()\n\n\n\n\n\n\n4.2.6 Themes\nThemes control the visual aspects of charts, such as titles, legends, axes, and background colors. Predefined themes, such as theme_bw(), theme_minimal(), and theme_classic(), offer consistent visual styles that can be applied to charts for a specific appearance.\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  theme_bw()\n\n\n\n\n\n\n\n\n\n\nTry it too\n\n\n\nDelete the last line from the example above, type theme_, press the tab key, and experiment with the different predefined themes in ggplot.\n\n\nAdditionally, we can define virtually all aspects of the chart. For example, to move the legend position to the bottom, we can use the function theme(legend.position = \"bottom\"). To change the font size, we can use the function theme(text = element_text(size = 12)). These settings can be combined in a single call to the theme() function, as shown below.\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  theme_bw() +\n  theme(legend.position = \"bottom\", \n        text = element_text(size = 12))\n\n\n\n\n\n\n4.2.7 Customization and Styling of Graphs\nThe labs() function is responsible for customizing labels and titles in plots. In the example below, we rename the x and y axes and assign a more descriptive name to the color legend, which in this case represents the continent.\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  labs(x = \"GDP per capita (log)\", \n       y = \"Life Expectancy\", \n       color = \"Continent\", \n       title = \"Relationship between GDP per capita and Life Expectancy\") +\n  theme_bw() +\n  theme(legend.position = \"bottom\")\n\n\n\n\nThe alpha parameter controls the opacity of geometric elements, ranging from 0 to 1. For example, geom_point(alpha = 0.5) makes the points semi-transparent, which can be useful for visualizing data overlaps in a scatter plot.\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point(alpha = 0.5) +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  labs(x = \"GDP per capita (log)\", \n       y = \"Life Expectancy\", \n       color = \"Continent\", \n       title = \"Relationship between GDP per capita and Life Expectancy\")\n\n\n\n\nTo choose specific colors for the levels of a categorical variable, we can use the scale_color_manual() function to manually assign colors to each level of the variable.\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point(alpha = 0.5) +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  scale_color_manual(values = c(\"blue\", \"green\", \"orange\", \"purple\", \"red\"))+\n  labs(x = \"GDP per capita (log)\", \n       y = \"Life Expectancy\", \n       color = \"Continent\", \n       title = \"Relationship between GDP per capita and Life Expectancy\")\n\n\n\n\n\n\n\n\n\n\nOther Color Palettes\n\n\n\nYou can use color palettes from the RColorBrewer package using the scale_color_brewer() function.\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point(alpha = 0.5) +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  scale_color_brewer(palette = \"Set1\")+\n  labs(x = \"GDP per capita (log)\", \n       y = \"Life Expectancy\", \n       color = \"Continent\", \n       title = \"Relationship between GDP per capita and Life Expectancy\")\n\n\n\n\nThe advantage of using RColorBrewer color palettes is that they are carefully designed to be perceptually distinct and suitable for representing different groups or categories in plots. This means that the colors in a palette are more easily distinguishable from each other, even when printed in black and white or viewed by people with visual impairments. See all available palettes here."
  },
  {
    "objectID": "04-visualizacao.html#additional-packages",
    "href": "04-visualizacao.html#additional-packages",
    "title": "4  Data Visualization",
    "section": "4.3 Additional Packages",
    "text": "4.3 Additional Packages\nThere are some extra packages that work as extensions of ggplot2. We present some in this section.\n\n4.3.1 The patchwork Package\nThe patchwork package is used to combine multiple ggplot2 plots into a single visualization. It allows you to create flexible and complex layouts, adding, organizing, and adjusting individual plots.\n\n# Install the patchwork package (only if not already installed)\ninstall.packages(\"patchwork\")\n\nAfter loading the package, you can use the + operator to combine ggplot2 plots into a single visualization.\nHere is a simple example creating two separate plots and then combining them using patchwork:\n\nlibrary(patchwork)\n\nWarning: package 'patchwork' was built under R version 4.2.3\n\nplot1 &lt;- ggplot(data = gapminder_2007, \n       mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) +\n  labs(x = \"GDP per capita (log)\", \n       y = \"Life Expectancy in 2007\", \n       title = \"Relationship between GDP per capita and Life Expectancy\") +\n  theme_classic()\n\nplot2 &lt;- ggplot(data = gapminder_2007, \n       mapping = aes(lifeExp)) +\n  geom_histogram() +\n  labs(title = \"Histogram of Life Expectancy\",\n       x = \"Life Expectancy in 2007\", \n       y = \"Frequency\") +\n  theme_classic()\n\nplot1 + plot2\n\n\n\n\n\n\n4.3.2 The ggthemes Package\nThe ggthemes package is an extension of ggplot2 that provides a variety of pre-defined themes to customize the appearance of plots. See the documentation here.\n\n# Install the ggthemes package (only if not already installed)\ninstall.packages(\"ggthemes\")\n\nAfter loading the package, you can apply any of the available themes to your ggplot2 plots using the theme_*() function. In the example below, three versions of the same plot are created with different themes. The + and / operators are used to define how the plots will be displayed.\n\n# Load the ggthemes package\nlibrary(ggthemes)\n\nWarning: package 'ggthemes' was built under R version 4.2.3\n\nplot0 &lt;- ggplot(data = gapminder_2007, \n       mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) +\n  labs(x = \"GDP per capita (log)\", \n       y = \"Life Expectancy in 2007\")\n\nplot1 &lt;- plot0 + theme_economist()\nplot2 &lt;- plot0 + theme_excel()\nplot3 &lt;- plot0 + theme_stata()\n\nplot1 +  (plot2 / plot3)\n\n\n\n\n\n\n4.3.3 The plotly Package\nThe plotly package offers features to create interactive plots. To add interactivity to the provided plot, we can use the ggplotly() function to convert a plot created with ggplot2 into an interactive plot. Use the command install.packages(\"plotly\") if you don’t have the package installed.\n\nlibrary(plotly)\n\nWarning: package 'plotly' was built under R version 4.2.3\n\ngrafico &lt;- ggplot(data = gapminder_anos, \n                  mapping = aes(x = gdpPercap, y = lifeExp, \n                                color = continent, text = country)) +\n  geom_point(alpha = 0.5) +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  labs(x = \"GDP per capita (log)\", \n       y = \"Life Expectancy\", \n       color = \"Continent\", \n       title = \"Relationship between GDP per capita and Life Expectancy\")\n\n\nggplotly(grafico)"
  },
  {
    "objectID": "04-visualizacao.html#extra-tips",
    "href": "04-visualizacao.html#extra-tips",
    "title": "4  Data Visualization",
    "section": "4.4 Extra Tips",
    "text": "4.4 Extra Tips\nWhen exploring different types of plots to visualize your data, the website Data to Viz can be a valuable tool. It provides a complete gallery of plot types and offers guidance on when and how to use each one. Additionally, the website provides specific examples of how to create these plots using different libraries, such as ggplot2 in R and matplotlib in Python."
  },
  {
    "objectID": "04-visualizacao.html#exercises",
    "href": "04-visualizacao.html#exercises",
    "title": "4  Data Visualization",
    "section": "4.5 Exercises",
    "text": "4.5 Exercises\n1. Let’s use the Billboard data presented in Section 3.7. Your task is to reproduce the plots below using data processing techniques with dplyr and data visualization with ggplot.\na) The plot below shows the history of each song in the ranking over the weeks.\n\n\n\n\n\nb) The plot below is a small modification of the one presented in item a); the x-axis shows the date the song entered the ranking.\n\n\n\n\n\nc) The plot below shows the ranking history of two songs: “Higher” and “With Arms Wide Open.”\n\n\n\n\n\n2. Use the data generated in Section 2.2.1 representing the closing price of a stock and reproduce the plot below, showing the evolution of the moving average over time.\n\n\n\n\n\n3. (Challenge) Reproduce the scatter plot presented in Section 2.3.\n\n\n\n\n\n4. Reproduce the figure presented in Section 3.5.6.\n\n\n\n\nRosling, Hans. 2012. “Data - Gapminder.org.” http://www.gapminder.org/data/.\n\n\nWilkinson, Leland. 2012. The Grammar of Graphics. Springer."
  },
  {
    "objectID": "05-fundamentos_python.html#instalação",
    "href": "05-fundamentos_python.html#instalação",
    "title": "5  Fundamentos de Python",
    "section": "5.1 Instalação",
    "text": "5.1 Instalação\nSiga os passos abaixo para realizar a instalação do Anaconda e do JupyterLab:\n\nBaixe e instale o Anaconda a partir do site oficial. Siga as instruções de instalação para o seu sistema operacional específico.\nApós instalar o Anaconda, abra o Anaconda Navigator e crie um novo ambiente virtual. Navegue até a seção “Environments” e clique em “Create” para adicionar um novo ambiente. Dê um nome ao ambiente e escolha a versão do Python que deseja usar.\nApós criar o ambiente virtual, ative-o clicando no ambiente virtual recém-criado na lista de ambientes e selecionando “Open Terminal”. No terminal, digite o comando conda activate nome_do_seu_ambiente (substitua nome_do_seu_ambiente pelo nome do ambiente que você criou).\nCom o ambiente virtual ativado, instale o JupyterLab digitando conda install jupyterlab no terminal.\nDepois de instalar o JupyterLab, execute-o digitando jupyter lab no terminal ou através da interface do Anaconda. Isso abrirá o JupyterLab no seu navegador padrão.\nNo JupyterLab, você pode criar um novo notebook Python clicando no ícone “+” na barra lateral esquerda e selecionando “Python 3” sob o cabeçalho “Notebook”."
  },
  {
    "objectID": "05-fundamentos_python.html#tipos-de-dados-fundamentais",
    "href": "05-fundamentos_python.html#tipos-de-dados-fundamentais",
    "title": "5  Fundamentos de Python",
    "section": "5.2 Tipos de dados fundamentais",
    "text": "5.2 Tipos de dados fundamentais\nEm Python, os tipos de dados fundamentais incluem integer, float, string e boolean:\n\nIntegers são números inteiros, como 1, 2, -3, etc. - Floats são números decimais, como 3.14, -0.5, etc.\nStrings são sequências de caracteres, como “hello”, “world”, “python”, etc.\nBooleans são valores lógicos que representam verdadeiro (True) ou falso (False).\n\nEsses tipos de dados são os blocos básicos para representar diferentes tipos de informações em Python, e são amplamente utilizados em programação para realizar operações e manipulações de dados.\n\n5.2.1 O tipo de dado inteiro\nUm tipo de dados inteiro (integer) em Python representa números inteiros, ou seja, números sem casas decimais. Por exemplo, 5, -10 e 0 são todos exemplos de números inteiros. No Python, os inteiros são representados pela classe int. Nos exemplos abaixo realizamos operações básicas com números inteiros.\n\n2 + 2  \n\n4\n\n\nNa primeira linha, calculamos a soma de 2 com 2.\n\nquantidade = 200\nprint(quantidade)\n\n200\n\ntype(quantidade)\n\n&lt;class 'int'&gt;\n\n\nAcima, atribuímos o valor 200 à variável quantidade e a imprimimos usando print(quantidade). Por fim, verificamos o tipo de dado da variável quantidade com type(quantidade), que retorna &lt;class 'int'&gt;, indicando que é um número inteiro.\n\n\n5.2.2 O tipo de dado ponto flutuante\nUm tipo de dado ponto flutuante (float) em Python representa números decimais, ou seja, números que podem ter uma parte fracionária. Por exemplo, 3.14, -0.001, e 2.71828 são todos floats. Em Python, os floats são representados pela classe float.\n\n1.75 + 2**3 \n\n9.75\n\ntaxa_juros = 1.25\n\nprint(taxa_juros)\n\n1.25\n\ntype(taxa_juros)\n\n&lt;class 'float'&gt;\n\n\nNa primeira linha do exemplo acima, calculamos a soma de 1.75 com 2 elevado à terceira potência. Em seguida, atribuímos o valor 1.25 à variável taxa_juros e a imprimimos usando print(taxa_juros). Por fim, verificamos o tipo de dado da variável taxa_juros com type(taxa_juros), que retorna &lt;class 'float'&gt;, indicando que é um número do tipo ponto flutuante.\n\n\n5.2.3 O tipo de dado cadeia de caracteres\n\npais = \"Brasil\" \n\nprint(pais)\n\nBrasil\n\ntype(pais)\n\n&lt;class 'str'&gt;\n\n\nNo código acima, criamos uma variável chamada pais e atribuímos a ela o valor “Brasil”, que é uma string. Em seguida, imprimimos o valor da variável pais usando print(pais), o que exibe “Brasil” na tela. Por fim, verificamos o tipo de dado da variável pais com type(pais), que retorna &lt;class 'str'&gt;, indicando que é uma string.\n\n\n5.2.4 O tipo de dado lógico\nO tipo de dados lógico, também conhecido como booleano (bool), é usado para representar valores de verdadeiro ou falso. No Python, os valores booleanos são True e False, que representam verdadeiro e falso, respectivamente.\n\n1 == 2\n\nFalse\n\n\n\n5 % 2 == 0\n\nFalse\n\n\n\ntaxa_juros_aumentando = True\nprint(taxa_juros_aumentando)\n\nTrue\n\ntype(taxa_juros_aumentando)\n\n&lt;class 'bool'&gt;\n\n\nNa primeira linha do exemplo acima, há uma verificação de igualdade entre 1 e 2, que retorna False porque 1 não é igual a 2. Em seguida, temos 5 % 2 == 0, que também retorna False porque o resto da divisão de 5 por 2 não é igual a zero. Por fim, temos a variável taxa_juros_aumentando atribuída a True, indicando que a taxa de juros está aumentando. Ao imprimir e verificar o tipo dessa variável, obtemos True como resultado e o tipo bool, indicando que é um valor lógico.\n\n\n5.2.5 Coerção de tipos\nA coerção de dados em Python refere-se à conversão forçada de um tipo de dado para outro.\n\nstr_num = \"1.41\"\ntype(str_num)\n\n&lt;class 'str'&gt;\n\n\n\nfloat(str_num)\n\n1.41\n\n\nVeja que a variável str_num é uma string que representa o número 1.41. Inicialmente, seu tipo é verificado usando a função type, que retorna &lt;class 'str'&gt;, indicando que é uma string. Em seguida, usamos a função float() para converter explicitamente str_num em um float. Após a conversão, o valor de str_num é “1.41” e seu tipo é alterado para &lt;class 'float'&gt;.\nA seguir, outros exemplos de cooerção.\nCoerção para inteiro:\n\nnum_float = 3.14\nnum_int = int(num_float)\nprint(num_int)\n\n3\n\n\nCoerção para lógico:\n\nvalor_inteiro = 0\nvalor_logico = bool(valor_inteiro)\nprint(valor_logico)\n\nFalse\n\n\nCoerção para string (str):\n\nnum_float = 3.14\nnum_str = str(num_float)\nprint(num_str) \n\n3.14\n\n\nNo código acima, estamos convertendo um valor float em string."
  },
  {
    "objectID": "05-fundamentos_python.html#objetos-básicos",
    "href": "05-fundamentos_python.html#objetos-básicos",
    "title": "5  Fundamentos de Python",
    "section": "5.3 Objetos básicos",
    "text": "5.3 Objetos básicos\nEm Python, há três estruturas de dados básicas: listas, tuplas e dicionários: - As listas são coleções ordenadas e mutáveis de elementos, permitindo a inclusão de itens de diferentes tipos e a modificação dos valores contidos nelas. - As tuplas são semelhantes às listas, porém são imutáveis, ou seja, não podem ser alteradas após a sua criação. - Já os dicionários são coleções não ordenadas de pares chave-valor, onde cada valor é associado a uma chave única, proporcionando acesso eficiente aos dados por meio das chaves.\n\n5.3.1 Listas\nEm Python, uma lista é uma estrutura de dados que permite armazenar uma coleção ordenada de elementos. Para criar uma lista, utilizamos colchetes [], e os elementos são separados por vírgulas. Podemos instanciar uma lista vazia simplesmente utilizando [] ou a função list(). Por exemplo:\n\nlista_vazia = [] # Lista vazia\nlista_vazia = list() # alternativa\n\n# lista com PIB de paises\npib_paises = [1800, 2500, 3200, 5600, 6700]\n\nNo exemplo acima, também temos a lista pib_paises que armazena o Produto Interno Bruto (PIB) de diferentes países. Para acessar elementos de uma lista em Python, podemos utilizar o índice do elemento desejado dentro de colchetes []. O índice começa do zero para o primeiro elemento, um para o segundo, e assim por diante. Por exemplo:\n\nprint(pib_paises[1])\n\n2500\n\n\nTambém podemos acessar os elementos a partir do final da lista utilizando índices negativos, onde -1 representa o último elemento, -2 o penúltimo, e assim por diante:\n\n# Acessando o último elemento\nultimo_elemento = pib_paises[-1]\nprint(ultimo_elemento)\n\n6700\n\n# Acessando o penúltimo elemento\npenultimo_elemento = pib_paises[-2]\nprint(penultimo_elemento)\n\n5600\n\n\nPodemos usar o método append()se desejamos adicionar um elemento ao final da lista, ou o método insert() se queremos adicionar um elemento em uma posição específica. Veja os exemplos de como usar ambos os métodos:\n\n# Adicionando elementos ao final da lista usando append()\npib_paises.append(2000)  # Adiciona o valor 2000 ao final da lista\n\n# Adicionando um elemento em uma posição específica usando insert()\npib_paises.insert(1, 1500)  # Adiciona o valor 1500 na posição 1 da lista\n\nPara verificar o tamanho de uma lista em Python, podemos usar a função len().\n\ntamanho_lista = len(pib_paises)\nprint(\"Tamanho da lista:\", tamanho_lista) \n\nTamanho da lista: 7\n\n\nPara ordenar uma lista, podemos usar o método sort() para ordenação in-place (ou seja, a lista é modificada) ou a função sorted() para retornar uma nova lista ordenada sem modificar a original:\n\n# Usando a função sorted() para retornar uma nova lista ordenada\nlista_ordenada = sorted(pib_paises)\nprint(\"Nova lista ordenada:\", lista_ordenada)\n\nNova lista ordenada: [1500, 1800, 2000, 2500, 3200, 5600, 6700]\n\n# Ordenando a lista usando o método sort()\npib_paises.sort()\nprint(\"Lista ordenada:\", pib_paises)\n\nLista ordenada: [1500, 1800, 2000, 2500, 3200, 5600, 6700]\n\n\nO método .pop() é usado para remover e retornar o último elemento de uma lista. Também podemos especificar um índice para remover e retornar um elemento em uma posição específica da lista. Aqui está como usar o método .pop():\n\n# Removendo e retornando o último PIB da lista\nultimo_pib = pib_paises.pop()\nprint(\"Último PIB removido:\", ultimo_pib) \n\nÚltimo PIB removido: 6700\n\nprint(\"Lista atualizada:\", pib_paises)\n\nLista atualizada: [1500, 1800, 2000, 2500, 3200, 5600]\n\n# Removendo e retornando o PIB de um país específico da lista\npib_removido = pib_paises.pop(1) \nprint(\"PIB removido:\", pib_removido) \n\nPIB removido: 1800\n\nprint(\"Lista atualizada:\", pib_paises)\n\nLista atualizada: [1500, 2000, 2500, 3200, 5600]\n\n\n\n\n5.3.2 Tuplas\nAs tuplas são estruturas de dados semelhantes às listas, mas com uma diferença fundamental: elas são imutáveis, ou seja, uma vez criadas, não podem ser modificadas. Elas são representadas por parênteses () em vez de colchetes [].\n\nx = (1, 2, 3) # tupla (lista imutável)\nprint(x)\n\n(1, 2, 3)\n\n\n# x[0] = 5 # gera erro!\n\nPodemos usar tuplas para representar informações que não devem ser alteradas, como por exemplo, as taxas de câmbio entre moedas. Veja:\n\ntaxas_cambio = ((\"USD\", \"EUR\", 0.82), (\"USD\", \"JPY\", 105.42), (\"EUR\", \"JPY\", 128.64))\n\nNeste exemplo, temos uma tupla de tuplas que representam as taxas de câmbio entre o dólar (USD), o euro (EUR) e o iene japonês (JPY) para uma data fixa fictícia. Cada tupla interna contém três elementos: a moeda de origem, a moeda de destino e a taxa de câmbio. Como essas informações não devem ser alteradas, uma tupla é uma escolha apropriada.\n\n\n\n\n\n\nTip\n\n\n\nPara acessar os elementos de uma tupla, você pode usar a mesma sintaxe que usa para acessar os elementos de uma lista, ou seja, usando colchetes [] e o índice do elemento desejado. Lembre-se de que os índices em Python começam em 0!\n\n\n\n\n5.3.3 Dicionários\nDicionários em Python são estruturas de dados que permitem armazenar pares de chave-valor. Cada valor é associado a uma chave específica, permitindo o acesso rápido aos dados por meio das chaves, em vez de índices numéricos, como em listas e tuplas. Essa estrutura é útil quando você precisa associar informações de maneira semelhante a um banco de dados, onde você pode buscar informações com base em uma chave específica.\nNo exemplo abaixo, temos cotações de ações de algumas empresas brasileiras listadas na bolsa de valores.\n\ncotacoes_acoes_brasileiras = {\n    \"PETR4\": 36.75,\n    \"VALE3\": 62.40,\n    \"ITUB4\": 34.15,\n    \"BBDC4\": 13.82\n}\n\nCada chave é o código de negociação da ação na bolsa, e o valor associado é o preço da ação em uma data fixada. Por exemplo, cotacoes_acoes_brasileiras[\"PETR4\"] retornaria o preço da ação da Petrobras.\nAlternativamente, você pode criar um dicionário usando a função dict:\n\ncotacoes_acoes_brasileiras = dict(PETR4=36.12, VALE3=62.40, ITUB4=34.15, BBDC4=13.82)\n\nVocê pode adicionar novos pares chave-valor a um dicionário ou atualizar os valores existentes. Por exemplo:\n\ncotacoes_acoes_brasileiras[\"ABEV3\"] = 12.80\ncotacoes_acoes_brasileiras[\"PETR4\"] = 36.75\n\nVocê pode remover pares chave-valor de um dicionário usando o comando método pop(). Por exemplo:\n\nvalor_removido = cotacoes_acoes_brasileiras.pop(\"BBDC4\")\n\nOutros métodos úteis para trabalhar com dicionários são keys(), values() e items() que retornam listas com as chaves, valores e itens do dicionário, respectivamente.\n\ncotacoes_acoes_brasileiras.keys() # retorna uma lista contendo todas as chaves\n\ndict_keys(['PETR4', 'VALE3', 'ITUB4', 'ABEV3'])\n\n\n\ncotacoes_acoes_brasileiras.values() # retorna uma lista contendo todos os valores\n\ndict_values([36.75, 62.4, 34.15, 12.8])\n\n\n\ncotacoes_acoes_brasileiras.items() # retorna uma lista de tuplas\n\ndict_items([('PETR4', 36.75), ('VALE3', 62.4), ('ITUB4', 34.15), ('ABEV3', 12.8)])"
  },
  {
    "objectID": "05-fundamentos_python.html#fatias-slices",
    "href": "05-fundamentos_python.html#fatias-slices",
    "title": "5  Fundamentos de Python",
    "section": "5.4 Fatias (slices)",
    "text": "5.4 Fatias (slices)\nO conceito de fatias, também conhecido como “slicing” em inglês, refere-se à técnica de extrair partes específicas de uma sequência, como uma lista, tupla ou string, usando índices. Ao utilizar fatias, você pode selecionar um intervalo de elementos dentro da sequência.\nA sintaxe básica para fatias é sequencia[inicio:fim:passo], onde:\n\ninicio: o índice inicial do intervalo a ser incluído na fatia (incluído).\nfim: o índice final do intervalo a ser incluído na fatia (excluído).\npasso: o tamanho do passo entre os elementos selecionados (opcional).\n\nConsidere a lista abaixo.\n\nnomes_paises = [\"Indonésia\", \"Índia\", \"Brasil\", \"África do Sul\", \"Alemanha\"]\n\nPara acessar os três primeiros países, podemos fazer:\n\nnomes_paises[:3]\n\n['Indonésia', 'Índia', 'Brasil']\n\n\nIsso retorna os elementos da lista do índice 0 (inclusivo) ao índice 3 (exclusivo).\nSe quisermos acessar os países do segundo ao terceiro:\n\nnomes_paises[1:4]\n\n['Índia', 'Brasil', 'África do Sul']\n\n\nPodemos até mesmo fazer fatias reversas, onde o índice inicial é maior que o índice final, indicando que queremos percorrer a lista de trás para frente. Por exemplo, para acessar os últimos três países:\n\nnomes_paises[-3:]\n\n['Brasil', 'África do Sul', 'Alemanha']\n\n\nSuponha que queremos acessar todos os países, mas pulando de dois em dois:\n\nnomes_paises[::2]\n\n['Indonésia', 'Brasil', 'Alemanha']\n\n\nNeste exemplo, o ::2 indica que queremos começar do início da lista e ir até o final, pulando de dois em dois elementos."
  },
  {
    "objectID": "05-fundamentos_python.html#condicionais",
    "href": "05-fundamentos_python.html#condicionais",
    "title": "5  Fundamentos de Python",
    "section": "5.5 Condicionais",
    "text": "5.5 Condicionais\nO if e o else são estruturas de controle de fluxo em Python, usadas para tomar decisões com base em condições.\nO bloco de código dentro do if é executado se a condição for avaliada como verdadeira (True). Por exemplo:\n\nidade = 18\nif idade &gt;= 18:\n    print(\"Você é maior de idade.\")\n\nVocê é maior de idade.\n\n\nO bloco de código dentro do else é executado se a condição do if for avaliada como falsa (False). Por exemplo:\n\nidade = 16\nif idade &gt;= 18:\n    print(\"Você é maior de idade.\")\nelse:\n    print(\"Você é menor de idade.\")\n\nVocê é menor de idade.\n\n\n\n\n\n\n\n\nIndentação\n\n\n\nEm Python, a indentação é fundamental para definir blocos de código. No exemplo acima, observe que o código dentro do if e do else está indentado com quatro espaços. Isso indica que essas linhas pertencem ao bloco de código condicional. Se não houver indentação correta, o Python gerará um erro de sintaxe."
  },
  {
    "objectID": "05-fundamentos_python.html#estruturas-repetitivas",
    "href": "05-fundamentos_python.html#estruturas-repetitivas",
    "title": "5  Fundamentos de Python",
    "section": "5.6 Estruturas repetitivas",
    "text": "5.6 Estruturas repetitivas\nAs estruturas de repetição são utilizadas para executar um bloco de código repetidamente com base em uma condição específica. Existem duas principais estruturas de repetição em Python: for e while.\n\n5.6.1 for\nO loop for é utilizado para iterar sobre uma sequência (como uma lista, tupla, dicionário, etc.) e executar um bloco de código para cada item da sequência. Por exemplo:\n\nfor x in range(0, 20, 3): # lembre da notação dos slices\n    print(x)\n\n0\n3\n6\n9\n12\n15\n18\n\n\n\nfor pais in nomes_paises:\n    print(\"País:\", pais)\n\nPaís: Indonésia\nPaís: Índia\nPaís: Brasil\nPaís: África do Sul\nPaís: Alemanha\n\n\nNo exemplo abaixo, temos uma lista de empresas e uma lista de lucros. Usando a função zip(), iteramos sobre essas duas listas em paralelo, imprimindo o nome da empresa e seu lucro correspondente. A função zip() combina elementos de duas ou mais sequências (como listas, tuplas, etc.) em pares ordenados.\n\nempresas = [\"Empresa A\", \"Empresa B\", \"Empresa C\"]\nlucros = [100000, 150000, 80000]\n\nfor empresa, lucro in zip(empresas, lucros):\n    print(\"O lucro da empresa \", empresa, \"foi R$\", lucro)\n\nO lucro da empresa  Empresa A foi R$ 100000\nO lucro da empresa  Empresa B foi R$ 150000\nO lucro da empresa  Empresa C foi R$ 80000\n\n\n\n\n5.6.2 while\nO while é uma estrutura de controle de fluxo que executa um bloco de código repetidamente enquanto uma condição especificada for verdadeira.\n\nanos = 1\ninvestimento = 1000\ntaxa_de_retorno = 0.05\n\nwhile anos &lt;= 10:\n    investimento *= (1 + taxa_de_retorno)\n    print(\"Após\", anos, \"anos, o investimento vale R$\", round(investimento, 2))\n    anos += 1\n\nApós 1 anos, o investimento vale R$ 1050.0\nApós 2 anos, o investimento vale R$ 1102.5\nApós 3 anos, o investimento vale R$ 1157.62\nApós 4 anos, o investimento vale R$ 1215.51\nApós 5 anos, o investimento vale R$ 1276.28\nApós 6 anos, o investimento vale R$ 1340.1\nApós 7 anos, o investimento vale R$ 1407.1\nApós 8 anos, o investimento vale R$ 1477.46\nApós 9 anos, o investimento vale R$ 1551.33\nApós 10 anos, o investimento vale R$ 1628.89\n\n\nNeste exemplo, o loop calcula o valor do investimento ao longo de 10 anos, considerando um retorno anual de 5%. A cada iteração, o valor do investimento é atualizado multiplicando-se pelo fator de crescimento (1 + taxa_de_retorno)."
  },
  {
    "objectID": "05-fundamentos_python.html#comprehensions",
    "href": "05-fundamentos_python.html#comprehensions",
    "title": "5  Python Fundamentals",
    "section": "5.7 Comprehensions",
    "text": "5.7 Comprehensions\nComprehensions are a concise and powerful way to create collections in Python, such as lists, dictionaries, and sets, from existing iterables like lists, dictionaries, sets, or sequences. They allow the creation of these collections more efficiently and readably compared to the traditional approach using loops. Comprehensions can include conditional expressions to filter elements or transform elements during collection creation.\nFor example, you can create a list of squares of numbers from 1 to 10 using a list comprehension:\n\nsquares = [x ** 2 for x in range(1, 11)]\nsquares\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\nThis is equivalent to:\n\nsquares = []\nfor x in range(1, 11):\n    squares.append(x ** 2)\n\nComprehensions can be applied to lists, dictionaries, and sets, and you can add conditional clauses to filter elements based on a specific condition.\nBelow, the variables rows and columns are defined as ranges from 1 to 3 and 1 to 2, respectively. Then, a list comprehension is used to generate all possible pairs, combining each value of row with each value of column. Finally, a for loop iterates over the list of pairs and prints each pair to the output. The result will be the printing of all possible ordered pairs, combining the specified row and column values.\n\nrows = range(1, 4)\ncolumns = range(1, 3)\n\npairs = [(r, c) for r in rows for c in columns]\n\nfor x in pairs:\n    print(x)\n\n(1, 1)\n(1, 2)\n(2, 1)\n(2, 2)\n(3, 1)\n(3, 2)\n\n\nIn the example below, the word “pneumonoultramicroscopicsilicovolcanoconiosis” is analyzed to count how many times each letter appears. Then, a loop is performed over the resulting dictionary to print the count of occurrences for each letter.\n\nword = \"pneumonoultramicroscopicsilicovolcanoconiosis\"\n\nletter_frequency = {letter: word.count(letter) for letter in word}\n\nfor letter, occurrences in letter_frequency.items():\n    print(\"The letter\", letter, \"occurs\", occurrences, \"times\" if occurrences &gt; 1 else \"time\")\n\nThe letter p occurs 2 times\nThe letter n occurs 4 times\nThe letter e occurs 1 time\nThe letter u occurs 2 times\nThe letter m occurs 2 times\nThe letter o occurs 9 times\nThe letter l occurs 3 times\nThe letter t occurs 1 time\nThe letter r occurs 2 times\nThe letter a occurs 2 times\nThe letter i occurs 6 times\nThe letter c occurs 6 times\nThe letter s occurs 4 times\nThe letter v occurs 1 time"
  },
  {
    "objectID": "05-fundamentos_python.html#funções",
    "href": "05-fundamentos_python.html#funções",
    "title": "5  Fundamentos de Python",
    "section": "5.8 Funções",
    "text": "5.8 Funções\nAs funções são blocos de código reutilizáveis que realizam uma tarefa específica.\nElas aceitam entradas, chamadas de argumentos, e podem retornar resultados.\nEm Python, a sintaxe básica de uma função é a seguinte:\n\ndef nome_da_funcao(argumento1, argumento2, ...):\n    # Corpo da função\n    # Faça alguma coisa com os argumentos\n    resultado = argumento1 + argumento2\n    return resultado\n\nPor exemplo, vamos criar uma função em Python chamada calcular_juros que calcula o montante final de um investimento com base no valor inicial, na taxa de juros e no número de anos:\n\ndef calcular_juros(valor_inicial, taxa_juros, anos):\n    montante_final = valor_inicial * (1 + taxa_juros) ** anos\n    return montante_final\n\nAgora, definimos valores e chamamos a função:\n\ninvestimento_inicial = 1000  # Valor inicial do investimento\ntaxa_juros_anual = 0.05      # Taxa de juros anual (5%)\nanos = 5                     # Número de anos\nresultado = calcular_juros(investimento_inicial, taxa_juros_anual, anos)\nprint(\"O montante final após\", anos, \"anos será de: R$\", round(resultado, 2))\n\nO montante final após 5 anos será de: R$ 1276.28\n\n\n\n5.8.1 Função lambda\nUma função lambda em Python é uma função anônima, o que significa que é uma função sem nome. Ela é definida usando a palavra-chave lambda e pode ter qualquer número de argumentos, mas apenas uma expressão. A sintaxe básica é a seguinte:\n\nlambda argumento1, argumento2, ...: expressao\n\nVeja um exemplo de uma função lambda que calcula o quadrado de um número:\n\nquadrado = lambda x: x ** 2\n\nNeste exemplo, lambda x: x ** 2 cria uma função que aceita um argumento x e retorna x ao quadrado. Você pode então usar essa função da mesma forma que qualquer outra função. Por exemplo:\n\nresultado = quadrado(5)\nprint(resultado)\n\n25\n\n\nAs funções lambda são frequentemente usadas em situações em que você precisa de uma função temporária e simples, como em operações de mapeamento, filtragem e ordenação de dados."
  },
  {
    "objectID": "05-fundamentos_python.html#classes-e-objetos",
    "href": "05-fundamentos_python.html#classes-e-objetos",
    "title": "5  Fundamentos de Python",
    "section": "5.9 Classes e objetos",
    "text": "5.9 Classes e objetos\nUma classe é uma estrutura que define o comportamento e as propriedades de um tipo de objeto. Podemos pensar em uma classe como uma representação de um conceito abstrato, como uma transação financeira ou um tipo específico de investimento.\nPor exemplo, podemos criar uma classe chamada Transacao para representar uma transação financeira, com propriedades como o valor da transação, a data e o tipo de transação.\nUm objeto, por outro lado, é uma instância específica de uma classe. Ele representa uma entidade concreta com suas próprias características e comportamentos. Continuando com o exemplo da classe Transacao, podemos criar objetos individuais para representar transações específicas, como a compra de ações de uma empresa em uma determinada data.\n\nclass Transacao:\n    def __init__(self, valor, data, tipo):\n        self.valor = valor\n        self.data = data\n        self.tipo = tipo\n    \n    def print_info(self):\n      print(f\"Tipo da transação: {self.tipo}, Valor: R${self.valor}, Data:{self.data}\")\n\nNeste exemplo, a classe Transacao possui um método especial __init__ que é chamado quando um novo objeto é criado. Esse método inicializa as propriedades do objeto com os valores fornecidos como argumentos. Além disso, a classe possui um método chamado print_info, que imprime as informações da transação, incluindo o tipo, o valor e a data. Esse método também recebe self como parâmetro para acessar os atributos da instância atual da classe. Ao chamar print_info() em um objeto Transacao, ele exibirá as informações formatadas da transação.\nA seguir, criamos dois objetos da classe Transacao, transacao1 e transacao2, e acessamos suas propriedades para obter informações sobre as transações.\n\n# Criando objetos da classe Transacao\ntransacao1 = Transacao(valor=1000, data=\"2024-03-11\", tipo=\"Compra de ações\")\ntransacao2 = Transacao(valor=500, data=\"2024-03-12\", tipo=\"Venda de ações\")\n\n# Acessando as propriedades dos objetos\nprint(\"Valor da transação 1:\", transacao1.valor)\n\nValor da transação 1: 1000\n\nprint(\"Data da transação 2:\", transacao2.data)\n\nData da transação 2: 2024-03-12\n\n# Acessando métodos dos objetos\ntransacao1.print_info()\n\nTipo da transação: Compra de ações, Valor: R$1000, Data:2024-03-11\n\ntransacao2.print_info()\n\nTipo da transação: Venda de ações, Valor: R$500, Data:2024-03-12"
  },
  {
    "objectID": "05-fundamentos_python.html#exercícios",
    "href": "05-fundamentos_python.html#exercícios",
    "title": "5  Fundamentos de Python",
    "section": "5.10 Exercícios",
    "text": "5.10 Exercícios\n1. Trabalhando com tipos de dados básicos\na) Crie variáveis para representar dados econômicos, como o PIB de pelo menos três países, taxas de inflação ou taxas de desemprego. Use valores recentes e históricos para criar um conjunto diversificado de dados econômicos que representem diferentes contextos econômicos ao redor do mundo.\nb) Realize operações matemáticas básicas com esses dados, como calcular médias, taxas de crescimento ou proporções. Por exemplo, você pode calcular médias dos valores do PIB, taxas de crescimento do PIB ao longo do tempo, proporções entre diferentes indicadores econômicos (como o PIB per capita em relação ao PIB total), entre outras operações.\n2. Durante a análise de dados, pode ser necessário converter entre diferentes tipos de dados. Utilize os tipos de dados fundamentais (integers, floats, strings) e aplique coerção de tipos conforme necessário. Considere, por exemplo que as variáveis representando o PIB foram dadas em formato string. Então, converta um tipo float para computar a média dos PIBs considerados. Depois disso, converta novamente os valores de PIB em uma string para formatação de saída ser no seguinte formato 1,111%.\n3. Utilize o código abaixo para gerar um pandas dataframe que representa o preço de fechamento de uma ação\n\nimport pandas as pd\n\n# Criando uma lista de datas\ndatas = pd.date_range(start='2023-01-01', end='2023-12-31', freq='B')  # Frequência 'B' para considerar apenas dias úteis\n\n# Criando uma série de preços de fechamento simulados\nimport numpy as np\nnp.random.seed(0)  # Define a semente aleatória para reprodutibilidade\nprecos_fechamento = np.random.normal(loc=50, scale=5, size=len(datas))  # Simulando preços com distribuição normal\n\n# Criando o DataFrame\ndf_precos_acoes = pd.DataFrame({'Data': datas, 'Preço de Fechamento': precos_fechamento})\n\n# Exibindo as primeiras linhas do DataFrame\nprint(df_precos_acoes.head())\n\n        Data  Preço de Fechamento\n0 2023-01-02            58.820262\n1 2023-01-03            52.000786\n2 2023-01-04            54.893690\n3 2023-01-05            61.204466\n4 2023-01-06            59.337790\n\n\na) Obtenha os preços de fechamento da ação durante do mês de janeiro determinado.\nb) Obtenha os preços de fechamento da ação entre 2023-06-01 e 2023-12-31.\nc) Obtenha os preços de fechamento da ação às sextas-feiras ao longo de todo o período. Calcule o preço de fechamento médio às segundas-feiras e compare com o das sextas-feiras. Qual deles apresenta maior desvio padrão?\n\n# Criando uma coluna para armazenar o dia da semana\ndf_precos_acoes['Dia da Semana'] = df_precos_acoes['Data'].dt.weekday\n\n# Exibindo as primeiras linhas do DataFrame com a nova coluna\nprint(df_precos_acoes.head())\n\n        Data  Preço de Fechamento  Dia da Semana\n0 2023-01-02            58.820262              0\n1 2023-01-03            52.000786              1\n2 2023-01-04            54.893690              2\n3 2023-01-05            61.204466              3\n4 2023-01-06            59.337790              4\n\n\n4. Considere a lista armazenada na variável pib_anos abaixo e utilize uma compreensão de lista para calcular o crescimento percentual do PIB em relação ao ano anterior para cada país.\n\n# Lista de PIB de um pais nos últimos cinco anos\npib_anos = [1000, 1200, 800, 1500, 2000]  # Exemplo de valores fictícios para o PIB\n\n5. Escreva uma função chamada calcular_ipc que receba três argumentos:\n\ncesta_de_produtos: Um dicionário que mapeia cada produto a sua quantidade na cesta.\nprecos_atual: Um dicionário que mapeia cada produto ao seu preço atual.\nprecos_base: Um dicionário que mapeia cada produto ao seu preço base (preço de referência). O IPC é calculado utilizando a seguinte fórmula: \\[IPC = \\sum_i \\frac{\\text{preço atual do produto}_i}{\\text{preço base do produto}_i}\\times \\text{quantidade do produto}_i.\\] A função deve retornar o valor calculado do IPC. Use o código abaixo para testar sua função.\n\n\n# Cesta de produtos com suas respectivas quantidades\ncesta_de_produtos = {'arroz': 1, 'feijao': 2, 'carne': 3}  \n# Preços atuais dos produtos\nprecos_atual = {'arroz': 5, 'feijao': 8, 'carne': 12}      \n# Preços base dos produtos\nprecos_base = {'arroz': 4, 'feijao': 7, 'carne': 10}      \n\n# Chamada da função para calcular o IPC\nipc = calcular_ipc(cesta_de_produtos, precos_atual, precos_base)\nprint(\"O Índice de Preços ao Consumidor (IPC) é:\", ipc)\n\n6. Você está encarregado de desenvolver um sistema para registrar e gerenciar transações de compra e venda de ações, além de calcular informações importantes sobre a carteira de investimentos. Para isso, você deve implementar duas classes em Python: Transacao e Carteira.\nA classe Transacao representa uma única transação de compra ou venda de ações. Ela possui os seguintes atributos:\n\ndata: uma string representando a data da transação no formato ‘AAAA-MM-DD’. tipo: uma string indicando o tipo da transação, que pode ser ‘compra’ ou ‘venda’.\nvalor: um número inteiro representando a quantidade de ações transacionadas.\n\nA classe Carteira representa a carteira de investimentos do usuário, que contém várias transações de ações. Ela possui os seguintes atributos: - transacoes: uma lista que armazena todas as transações de ações realizadas.\nAlém disso, a classe Carteira possui os seguintes métodos:\n\nadicionar_transacao(transacao): adiciona uma nova transação à carteira.\ncalcular_posicao_atual(valor_atual_acao): calcula a posição atual da ação na carteira com base no valor atual da ação.\ncalcular_valor_presente(valor_atual_acao): calcula o valor presente da ação na carteira com base no valor atual da ação.\n\na) Implemente as classes Transacao e Carteira com os atributos e métodos descritos acima.\nb) Crie três instâncias da classe Transacao para representar diferentes transações de compra e venda de ações.\nc) Crie uma instância da classe Carteira e adicione as transações criadas à carteira.\nd) Teste os métodos da classe Carteira, utilizando os exemplos fornecidos no código de teste abaixo.\n\n# Criando algumas transações\ntransacao1 = Transacao('2024-03-18', 'compra', 10)  # Compra de 10 ações\ntransacao2 = Transacao('2024-03-19', 'compra', 5)   # Compra de mais 5 ações\ntransacao3 = Transacao('2024-03-20', 'venda', 8)    # Venda de 8 ações\n\n# Criando uma carteira e adicionando as transações\ncarteira = Carteira()\ncarteira.adicionar_transacao(transacao1)\ncarteira.adicionar_transacao(transacao2)\ncarteira.adicionar_transacao(transacao3)\n\n# Valor atual da ação (hipotético)\nvalor_atual_acao = 50\n\n# Testando os métodos da classe Carteira\nposicao_atual = carteira.calcular_posicao_atual(valor_atual_acao)\nvalor_presente = carteira.calcular_valor_presente(valor_atual_acao)\n\n# Exibindo os resultados\nprint(\"Posição atual da ação na carteira:\", posicao_atual)\nprint(\"Valor presente na carteira:\", valor_presente)\n\n\n\n\n\nMcKinney, Wes. 2022. Python for Data Analysis. \" O’Reilly Media, Inc.\"."
  },
  {
    "objectID": "06-visualizacao_python.html#instalação-de-bibliotecas",
    "href": "06-visualizacao_python.html#instalação-de-bibliotecas",
    "title": "6  Processamento e visualização de dados",
    "section": "6.1 Instalação de bibliotecas",
    "text": "6.1 Instalação de bibliotecas\nA instalação de bibliotecas em Python é essencial para expandir a funcionalidade da linguagem. Existem várias maneiras de instalar bibliotecas, mas a mais comum é usando um gerenciador de pacotes. O pip é o gerenciador de pacotes padrão para Python e geralmente acompanha a instalação do Python.\nPara instalar uma biblioteca com pip, abra o terminal ou prompt de comando e digite o seguinte comando:\n\npip install nome_da_biblioteca\n\nSubstitua nome_da_biblioteca pelo nome da biblioteca que você deseja instalar."
  },
  {
    "objectID": "06-visualizacao_python.html#processamento-de-dados-numéricos",
    "href": "06-visualizacao_python.html#processamento-de-dados-numéricos",
    "title": "6  Processamento e visualização de dados",
    "section": "6.2 Processamento de dados numéricos",
    "text": "6.2 Processamento de dados numéricos\nO NumPy (Numerical Python) é uma biblioteca essencial para computação numérica em Python. Ele fornece estruturas de dados eficientes para trabalhar com arrays multidimensionais e funções matemáticas poderosas para manipulação de dados.\nPara instalar o NumPy, você pode usar o pip, que é o gerenciador de pacotes padrão do Python:\n\npip install numpy\n\nO principal objeto em NumPy é o array multidimensional. Você pode criar arrays NumPy usando a função numpy.array() e realizar operações matemáticas básicas com eles:\n\nimport numpy as np\n\n# Criando um array NumPy\narr = np.array([1, 2, 3, 4, 5])\n\n# Operações matemáticas básicas\nprint(\"Soma:\", np.sum(arr))\n\nSoma: 15\n\nprint(\"Média:\", np.mean(arr))\n\nMédia: 3.0\n\n\nAlém das operações básicas, o NumPy oferece funções universais (ufuncs) para aplicar operações em todos os elementos de um array de uma vez:\n\n# Funções universais (ufuncs)\narr = np.array([1, 2, 3, 4, 5])\nprint(\"Quadrado de cada elemento:\", np.square(arr))\n\nQuadrado de cada elemento: [ 1  4  9 16 25]\n\nprint(\"Exponencial de cada elemento:\", np.exp(arr))\n\nExponencial de cada elemento: [  2.71828183   7.3890561   20.08553692  54.59815003 148.4131591 ]\n\n\nA seguir, apresentamos três exemplos práticos de utilização das funções do NumPy.\nExemplo 1: Cálculo de Estatísticas Descritivas\nO NumPy pode ser usado para calcular estatísticas descritivas, como média, mediana, desvio padrão, mínimo e máximo de séries temporais de dados econômicos, como o preço das ações de uma empresa ao longo do tempo.\n\nimport numpy as np\n\n# Preço das ações de uma empresa ao longo do tempo (em dólares)\nprecos = np.array([100, 102, 105, 110, 108, 115, 120])\n\n# Calculando estatísticas descritivas\nprint(\"Média:\", np.mean(precos))\n\nMédia: 108.57142857142857\n\nprint(\"Desvio padrão:\", np.std(precos))\n\nDesvio padrão: 6.58693821908486\n\nprint(\"Máximo:\", np.max(precos))\n\nMáximo: 120\n\nprint(\"Mínimo:\", np.min(precos))\n\nMínimo: 100\n\n\nExemplo 2: Análise de Séries Temporais O NumPy é útil para manipulação e análise de séries temporais. Por exemplo, você pode usar NumPy para calcular a taxa de retorno de um investimento ao longo do tempo ou para suavizar uma série temporal usando médias móveis.\n\nprecos = np.array([100, 102, 105, 110, 108, 115, 120])\n# Calcular a taxa de retorno de um investimento ao longo do tempo\nretornos = np.diff(precos) / precos[:-1] * 100\nprint(\"Taxa de retorno:\", retornos)\n\nTaxa de retorno: [ 2.          2.94117647  4.76190476 -1.81818182  6.48148148  4.34782609]\n\n\n\n\n\n\n\n\nTip\n\n\n\nA função np.diff em NumPy é usada para calcular a diferença entre elementos consecutivos ao longo de um determinado eixo de um array. Atenção: O tamanho do retorno da função np.diff será sempre menor que o tamanho do vetor original de entrada por um elemento. Por exemplo, se tivermos um vetor unidimensional com \\(n\\) elementos, a função np.diff retornará um vetor com \\(n−1\\) elementos, pois não há diferença para o último elemento.\n\n\n\nprecos = np.array([100, 102, 105, 110, 108, 115, 120])\n# Suavizar uma série temporal usando médias móveis\ntamanho_janela = 3\nmedia_movel = np.convolve(precos, np.ones(tamanho_janela) / tamanho_janela, mode='valid')\nprint(\"Médias móveis:\", media_movel)\n\nMédias móveis: [102.33333333 105.66666667 107.66666667 111.         114.33333333]\n\n\n\n\n\n\n\n\nTip\n\n\n\nA função np.convolve em NumPy é usada para realizar a convolução entre duas sequências, representadas por dois vetores unidimensionais. A convolução é uma operação matemática que combina duas funções para produzir uma terceira função que representa a quantidade de sobreposição entre elas conforme uma delas é deslocada ao longo do eixo.\nA sintaxe básica da função é np.convolve(a, b, mode='full'), onde a e b são os dois vetores unidimensionais a serem convolvidos e mode é um parâmetro opcional que define o modo de convolução. Os modos mais comuns são:\n\n'full': Retorna a saída completa da convolução. O comprimento do resultado será len(a) + len(b) - 1.\n'valid': Retorna apenas pontos onde as sequências se sobrepõem completamente. O comprimento do resultado será max(len(a), len(b)) - min(len(a), len(b)) + 1.\n'same': Retorna a saída do mesmo tamanho que o vetor de entrada mais longo. O comprimento do resultado será max(len(a), len(b)).\n\nNo exemplo anterior, a função np.convolve foi usada aqui para calcular a média móvel dos preços. Nesse caso, a primeira sequência é o vetor de preços e a segunda sequência é um vetor de 1s dividido pelo tamanho da janela de média móvel. Isso cria uma sequência que representa uma média ponderada dos valores.\n\n\nExemplo 3: Simulação Monte Carlo O NumPy pode ser usado para realizar simulações Monte Carlo, que são amplamente utilizadas na modelagem financeira e na avaliação de risco. Por exemplo, você pode simular o desempenho de uma carteira de investimentos ao longo do tempo sob diferentes cenários de mercado.\n\n# Simulação Monte Carlo do desempenho de uma carteira de investimentos\nnum_simulacoes = 1000\nnum_anos = 10\nretorno_medio = 0.08\nvolatilidade = 0.15\n\n# Gerar retornos aleatórios usando uma distribuição normal\nretornos = np.random.normal(retorno_medio, volatilidade, size=(num_simulacoes, num_anos))\n\n# Calcular o valor final da carteira para cada simulação\ninvestimento_inicial = 10000\nvalores_finais = investimento_inicial * np.cumprod(1 + retornos, axis=1)\n\n# Estatísticas descritivas dos valores finais da carteira\nprint(\"Valor final médio:\", np.mean(valores_finais[:,-1]))\n\nValor final médio: 21277.309029347114\n\nprint(\"Desvio padrão dos valores finais:\", np.std(valores_finais[:,-1]))\n\nDesvio padrão dos valores finais: 9571.011821238177\n\n\nMais referências sobre NumPy:\n\nDocumentação oficial do NumPy: https://numpy.org/doc/stable/ A documentação oficial do NumPy contém informações detalhadas sobre todas as funções e métodos disponíveis, além de tutoriais e exemplos.\nNumPy Quickstart Tutorial: https://numpy.org/doc/stable/user/quickstart.html Este tutorial rápido fornece uma introdução rápida ao NumPy e suas funcionalidades básicas."
  },
  {
    "objectID": "06-visualizacao_python.html#análise-e-processamento-de-dados",
    "href": "06-visualizacao_python.html#análise-e-processamento-de-dados",
    "title": "6  Processamento e visualização de dados",
    "section": "6.3 Análise e processamento de dados",
    "text": "6.3 Análise e processamento de dados\nO pandas é uma biblioteca de código aberto amplamente utilizada em Python para análise e manipulação de dados. Ele fornece estruturas de dados flexíveis e ferramentas poderosas para trabalhar com dados estruturados, facilitando a análise, limpeza e preparação de dados para diversas aplicações, como ciência de dados, finanças, pesquisa acadêmica e muito mais."
  },
  {
    "objectID": "06-visualizacao_python.html#o-que-é-pandas",
    "href": "06-visualizacao_python.html#o-que-é-pandas",
    "title": "6  Processamento e visualização de dados",
    "section": "6.4 O que é pandas?",
    "text": "6.4 O que é pandas?\nPandas é uma biblioteca Python de código aberto que oferece estruturas de dados de alto desempenho e ferramentas de análise de dados. O pandas foi projetado para lidar com as complexidades do mundo real em análise de dados, oferecendo uma interface simples e intuitiva para trabalhar com dados tabulares.\nPandas é amplamente utilizado em análise de dados devido à sua capacidade de:\n\nImportar e exportar dados de uma variedade de fontes, incluindo arquivos CSV, Excel, SQL, JSON, HDF5 e mais.\nManipular dados de forma eficiente, incluindo indexação, filtragem, agregação e limpeza.\nRealizar operações estatísticas e matemáticas em dados, como média, soma, desvio padrão, correlação, etc.\n\nAs duas principais estruturas de dados fornecidas pelo pandas são series e dataframes.\n\n6.4.1 Séries\nUma Serie é uma estrutura de dados unidimensional que pode conter qualquer tipo de dados, como inteiros, floats, strings, entre outros. Cada elemento em uma Série possui um rótulo único chamado de índice. A Série é semelhante a uma lista ou array unidimensional em Python, mas fornece recursos adicionais, como operações vetorizadas e alinhamento automático de dados com base nos rótulos de índice.\nSuponha que temos uma Série representando os preços diários de uma ação:\n\n\n\nData\nPreço\n\n\n\n\n2024-03-18\n100\n\n\n2024-03-19\n105\n\n\n2024-03-20\n98\n\n\n2024-03-21\n102\n\n\n\nPodemos criar uma Serie pandas para representar esses dados:\n\nimport pandas as pd\n\n# Dados dos preços da ação\ndata = ['2024-03-18', '2024-03-19', '2024-03-20', '2024-03-21']\nprecos = [100, 105, 98, 102]\n\n# Criando uma Série pandas\nserie_precos_acao = pd.Series(precos, index=pd.to_datetime(data), name='Preço da Ação')\nprint(serie_precos_acao)\n\n2024-03-18    100\n2024-03-19    105\n2024-03-20     98\n2024-03-21    102\nName: Preço da Ação, dtype: int64\n\n\n\n\n6.4.2 DataFrame\nDataFrame é uma estrutura de dados bidimensional semelhante a uma tabela de banco de dados ou uma planilha do Excel. Ele é composto por linhas e colunas, onde cada coluna pode conter um tipo de dado diferente. Cada coluna e linha em um DataFrame possui um rótulo exclusivo chamado de índice e nome, respectivamente. O DataFrame permite realizar uma ampla gama de operações de manipulação e análise de dados, como indexação, filtragem, agregação, limpeza, entre outras.\nSuponha que temos um DataFrame representando os preços diários de várias ações. Podemos criar um DataFrame pandas para representar esses dados. Veja no exemplo abaixo.\n\nimport pandas as pd\nimport numpy as np\n\n# Dados dos preços das ações\ndata = ['2024-03-18', '2024-03-19', '2024-03-20', '2024-03-21']\nprecos_acoes = {\n    'Ação 1': [100, 105, np.nan, 102],\n    'Ação 2': [50, 52, 48, 49],\n    'Ação 3': [75, np.nan, 72, 74]\n}\n\n# Criando um DataFrame pandas\ndf_precos_acoes = pd.DataFrame(precos_acoes, index=pd.to_datetime(data))\nprint(df_precos_acoes)\n\n            Ação 1  Ação 2  Ação 3\n2024-03-18   100.0      50    75.0\n2024-03-19   105.0      52     NaN\n2024-03-20     NaN      48    72.0\n2024-03-21   102.0      49    74.0\n\n\n\n\n6.4.3 Principais funcionalidades\nA função df.isna() é uma função fornecida pelo pandas em um DataFrame (df) que retorna uma matriz booleana indicando se cada elemento do DataFrame é um valor ausente (NaN).\nQuando aplicada a um DataFrame, a função isna() retorna um DataFrame com o mesmo formato, onde cada valor é substituído por True se for NaN e False caso contrário.\nIsso é útil para identificar rapidamente os valores ausentes em um DataFrame e realizar operações de limpeza ou tratamento de dados, como preenchimento de valores ausentes ou remoção de linhas ou colunas contendo esses valores.\nSe aplicarmos df_precos_acoes.isna(), obteremos:\n\ndf_precos_acoes.isna()\n\n            Ação 1  Ação 2  Ação 3\n2024-03-18   False   False   False\n2024-03-19   False   False    True\n2024-03-20    True   False   False\n2024-03-21   False   False   False\n\n\nPara contar a quantidade de NaN em cada coluna, combine is.na() com sum():\n\ndf_precos_acoes.isna().sum()\n\nAção 1    1\nAção 2    0\nAção 3    1\ndtype: int64\n\n\nO método dropna() no pandas é usado para remover linhas ou colunas que contenham valores ausentes (NaN).\n\ndf_precos_acoes.dropna()\n\n            Ação 1  Ação 2  Ação 3\n2024-03-18   100.0      50    75.0\n2024-03-21   102.0      49    74.0\n\n\nO parâmetro subset é usado para especificar em quais colunas ou linhas o pandas deve procurar por valores ausentes antes de remover. Quando usamos df.dropna(subset=[\"Ação 3\"]), estamos instruindo o pandas a remover todas as linhas onde houver um valor ausente na coluna “Ação 3”.\n\ndf_precos_acoes.dropna(subset=[\"Ação 3\"])\n\n            Ação 1  Ação 2  Ação 3\n2024-03-18   100.0      50    75.0\n2024-03-20     NaN      48    72.0\n2024-03-21   102.0      49    74.0\n\n\nNa função dropna(), o parâmetro inplace=True especifica que a modificação deve ser feita diretamente no DataFrame original, em vez de retornar um novo DataFrame sem os valores ausentes. Quando inplace=True é usado com dropna(), o DataFrame original é modificado e as linhas ou colunas com valores ausentes são removidas permanentemente.\n\ndf_precos_acoes.dropna(inplace = True)\n\nA função fillna() no pandas é usada para preencher valores ausentes (NaN) em um DataFrame com um valor específico.\nConsidere o seguinte DataFrame df que representa os dados de clientes de um banco com alguns dados faltantes:\n\nimport pandas as pd\nimport numpy as np\n\ndados = {'Nome': ['João', 'Maria', 'Pedro', 'Ana', 'Mariana'],\n        'Idade': [25, 30, np.nan, 40, 35],\n        'Renda Mensal': [5000, 6000, np.nan, 4500, 5500],\n        'Limite de Crédito': [10000, np.nan, 8000, 12000, np.nan]}\ndf_clientes = pd.DataFrame(dados)\n\nNeste exemplo,\n\nOs valores ausentes na coluna “Idade” foram preenchidos com a mediana das idades existentes no DataFrame.\nOs valores ausentes na coluna “Limite de Crédito” foram preenchidos com a moda dos limites de crédito existentes no DataFrame.\nOs valores ausentes na coluna “Renda Mensal” foram preenchidos com a média das rendas mensais existentes no DataFrame.\n\n\n# Preenchendo valores ausentes na coluna 'Idade' com a mediana das idades\ndf_clientes['Idade'] = df_clientes['Idade'].fillna(df_clientes['Idade'].median())\n\n# Preenchendo valores ausentes na coluna 'Limite de Crédito' com a moda dos limites de crédito\ndf_clientes['Limite de Crédito'] = df_clientes['Limite de Crédito'].fillna(df_clientes['Limite de Crédito'].mode()[0])\n\n# Preenchendo valores ausentes na coluna 'Renda Mensal' com a média das rendas mensais\ndf_clientes['Renda Mensal'] = df_clientes['Renda Mensal'].fillna(df_clientes['Renda Mensal'].mean())\n\ndf_clientes\n\n      Nome  Idade  Renda Mensal  Limite de Crédito\n0     João   25.0        5000.0            10000.0\n1    Maria   30.0        6000.0             8000.0\n2    Pedro   32.5        5250.0             8000.0\n3      Ana   40.0        4500.0            12000.0\n4  Mariana   35.0        5500.0             8000.0\n\n\nAgora, vamos carregar os dados gapminder, que está no arquivo gapminder.zip.\n\ngapminder = pd.read_csv(\"data/gapminder.zip\", sep = \"\\t\")\n\nA função head() é usada para visualizar as primeiras linhas do conjunto de dados gapminder, oferecendo uma rápida visão geral da sua estrutura e conteúdo.\n\ngapminder.head()\n\n       country continent  year  lifeExp       pop   gdpPercap\n0  Afghanistan      Asia  1952   28.801   8425333  779.445314\n1  Afghanistan      Asia  1957   30.332   9240934  820.853030\n2  Afghanistan      Asia  1962   31.997  10267083  853.100710\n3  Afghanistan      Asia  1967   34.020  11537966  836.197138\n4  Afghanistan      Asia  1972   36.088  13079460  739.981106\n\n\nO método info() fornece informações sobre o conjunto de dados, incluindo o número de entradas, o tipo de dados de cada coluna e se há valores nulos.\n\ngapminder.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 1704 entries, 0 to 1703\nData columns (total 6 columns):\n #   Column     Non-Null Count  Dtype  \n---  ------     --------------  -----  \n 0   country    1704 non-null   object \n 1   continent  1704 non-null   object \n 2   year       1704 non-null   int64  \n 3   lifeExp    1704 non-null   float64\n 4   pop        1704 non-null   int64  \n 5   gdpPercap  1704 non-null   float64\ndtypes: float64(2), int64(2), object(2)\nmemory usage: 80.0+ KB\n\n\nA função describe() gera estatísticas descritivas para cada coluna numérica do conjunto de dados, como contagem, média, desvio padrão, mínimo e máximo.\n\ngapminder.describe()\n\n             year      lifeExp           pop      gdpPercap\ncount  1704.00000  1704.000000  1.704000e+03    1704.000000\nmean   1979.50000    59.474439  2.960121e+07    7215.327081\nstd      17.26533    12.917107  1.061579e+08    9857.454543\nmin    1952.00000    23.599000  6.001100e+04     241.165876\n25%    1965.75000    48.198000  2.793664e+06    1202.060309\n50%    1979.50000    60.712500  7.023596e+06    3531.846988\n75%    1993.25000    70.845500  1.958522e+07    9325.462346\nmax    2007.00000    82.603000  1.318683e+09  113523.132900\n\n\nA função value_counts() conta o número de ocorrências de cada categoria na coluna “continent” do conjunto de dados gapminder, transforma os resultados em um DataFrame, renomeia as colunas para “continent” e “n” (indicando a contagem), e reconfigura o índice.\n\ngapminder.value_counts(\"continent\").to_frame(\"n\").reset_index()\n\n  continent    n\n0    Africa  624\n1      Asia  396\n2    Europe  360\n3  Americas  300\n4   Oceania   24\n\n\nNo trecho abaixo, fazemos uma contagem de valores para as combinações únicas de categorias nas colunas “continent” e “year” do DataFrame gapminder. Os resultados são transformados em um DataFrame, renomeados como “continent”, “year” e “n” (indicando a contagem), e o índice é reconfigurado.\n\ngapminder.value_counts([\"continent\", \"year\"]).to_frame(\"n\").reset_index()\n\n   continent  year   n\n0     Africa  1952  52\n1     Africa  1987  52\n2     Africa  1957  52\n3     Africa  2002  52\n4     Africa  1997  52\n5     Africa  1992  52\n6     Africa  2007  52\n7     Africa  1982  52\n8     Africa  1977  52\n9     Africa  1972  52\n10    Africa  1967  52\n11    Africa  1962  52\n12      Asia  1952  33\n13      Asia  2007  33\n14      Asia  2002  33\n15      Asia  1997  33\n16      Asia  1992  33\n17      Asia  1987  33\n18      Asia  1977  33\n19      Asia  1972  33\n20      Asia  1967  33\n21      Asia  1962  33\n22      Asia  1957  33\n23      Asia  1982  33\n24    Europe  1982  30\n25    Europe  1957  30\n26    Europe  2007  30\n27    Europe  2002  30\n28    Europe  1997  30\n29    Europe  1992  30\n30    Europe  1987  30\n31    Europe  1977  30\n32    Europe  1972  30\n33    Europe  1967  30\n34    Europe  1962  30\n35    Europe  1952  30\n36  Americas  2002  25\n37  Americas  2007  25\n38  Americas  1952  25\n39  Americas  1962  25\n40  Americas  1967  25\n41  Americas  1972  25\n42  Americas  1977  25\n43  Americas  1982  25\n44  Americas  1987  25\n45  Americas  1992  25\n46  Americas  1997  25\n47  Americas  1957  25\n48   Oceania  1982   2\n49   Oceania  2002   2\n50   Oceania  1997   2\n51   Oceania  1992   2\n52   Oceania  1987   2\n53   Oceania  1957   2\n54   Oceania  1977   2\n55   Oceania  1972   2\n56   Oceania  1967   2\n57   Oceania  1962   2\n58   Oceania  1952   2\n59   Oceania  2007   2"
  },
  {
    "objectID": "06-visualizacao_python.html#dados-organizados-tidy-data",
    "href": "06-visualizacao_python.html#dados-organizados-tidy-data",
    "title": "6  Processamento e visualização de dados",
    "section": "6.5 Dados organizados (tidy data)",
    "text": "6.5 Dados organizados (tidy data)\nTodas as tabelas abaixo tem o mesmo dado (foram tiradas do pacote tidyr do R), que mostra a quantidade de casos de uma doença e a população total de alguns países.\n\ntable1 = pd.read_csv(\"data/table1.csv\")\ntable2 = pd.read_csv(\"data/table2.csv\")\ntable3 = pd.read_csv(\"data/table3.csv\")\ntable4a = pd.read_csv(\"data/table4a.csv\")\ntable4b = pd.read_csv(\"data/table4b.csv\")\n\n\ntable1\n\n       country  year   cases  population\n0  Afghanistan  1999     745    19987071\n1  Afghanistan  2000    2666    20595360\n2       Brazil  1999   37737   172006362\n3       Brazil  2000   80488   174504898\n4        China  1999  212258  1272915272\n5        China  2000  213766  1280428583\n\n\n\ntable2\n\n        country  year        type       count\n0   Afghanistan  1999       cases         745\n1   Afghanistan  1999  population    19987071\n2   Afghanistan  2000       cases        2666\n3   Afghanistan  2000  population    20595360\n4        Brazil  1999       cases       37737\n5        Brazil  1999  population   172006362\n6        Brazil  2000       cases       80488\n7        Brazil  2000  population   174504898\n8         China  1999       cases      212258\n9         China  1999  population  1272915272\n10        China  2000       cases      213766\n11        China  2000  population  1280428583\n\n\n\ntable3\n\n       country  year               rate\n0  Afghanistan  1999       745/19987071\n1  Afghanistan  2000      2666/20595360\n2       Brazil  1999    37737/172006362\n3       Brazil  2000    80488/174504898\n4        China  1999  212258/1272915272\n5        China  2000  213766/1280428583\n\n\n\ntable4a\n\n       country    1999    2000\n0  Afghanistan     745    2666\n1       Brazil   37737   80488\n2        China  212258  213766\n\n\n\ntable4b\n\n       country        1999        2000\n0  Afghanistan    19987071    20595360\n1       Brazil   172006362   174504898\n2        China  1272915272  1280428583\n\n\nO exemplo abaixo cria uma nova coluna chamada rate no DataFrame table1. A função assign adiciona uma nova coluna ao DataFrame, enquanto a expressão lambda calcula os valores para essa nova coluna.\n\ntable1.assign(rate = lambda _: 10000 * (_.cases / _.population))\n\n       country  year   cases  population      rate\n0  Afghanistan  1999     745    19987071  0.372741\n1  Afghanistan  2000    2666    20595360  1.294466\n2       Brazil  1999   37737   172006362  2.193930\n3       Brazil  2000   80488   174504898  4.612363\n4        China  1999  212258  1272915272  1.667495\n5        China  2000  213766  1280428583  1.669488\n\n\nNo exemplo abaixo, agrupamos os dados do DataFrame table1 pela coluna “year” (ano) e depois calcula a soma dos casos para cada ano. O método groupby(\"year\") agrupa os dados por ano, criando grupos separados para cada ano. as_index = False especifica que a coluna usada para agrupamento (“year”) não deve ser definida como índice no DataFrame resultante. O método agg é usado para realizar uma operação de agregação nos grupos. Aqui, np.sum é usado para calcular a soma dos valores da coluna “cases” para cada grupo.\n\n(table1.groupby(\"year\", as_index = False)\n       .agg(total_cases = (\"cases\", np.sum)))\n\n   year  total_cases\n0  1999       250740\n1  2000       296920\n\n\nPara fazer o mesmo com os dados da table1, temos que usar a função pivot_table:\n\ntable2_tidy = (table2.pivot_table(index = [\"country\", \"year\"], columns = \"type\", values = \"count\")\n               .reset_index()\n               .rename_axis(None, axis = 1))\n\ntable2_tidy.assign(rate = lambda _: 10000 * (_.cases / _.population))\n\n       country  year     cases    population      rate\n0  Afghanistan  1999     745.0  1.998707e+07  0.372741\n1  Afghanistan  2000    2666.0  2.059536e+07  1.294466\n2       Brazil  1999   37737.0  1.720064e+08  2.193930\n3       Brazil  2000   80488.0  1.745049e+08  4.612363\n4        China  1999  212258.0  1.272915e+09  1.667495\n5        China  2000  213766.0  1.280429e+09  1.669488\n\n\nNo exemplo acima, usamos o método pivot_table do pandas para reorganizar os dados do DataFrame table2. Ele reorganiza os dados de forma que os valores da coluna “count” sejam pivotados (transformados em colunas) com base nos valores únicos da combinação de “country” e “year”. Os parâmetros index, columns e values especificam respectivamente as colunas que serão usadas como índice, as que serão transformadas em colunas e os valores a serem preenchidos na tabela pivô. Após a operação de pivotagem, são encadeados métodos adicionais para modificar a estrutura do DataFrame resultante:\n\nreset_index() redefine os índices do DataFrame para índices numéricos padrão, movendo os índices anteriores (no caso, “country” e “year”) para colunas.\nrename_axis(None, axis=1) remove os nomes dos índices das colunas, substituindo-os por None. Isso é feito especificamente para limpar os nomes das colunas do DataFrame.\n\nApós a transformação dos dados, a função assign é usada para criar uma nova coluna chamada rate no DataFrame resultante table2_tidy.\nAgora, vamos fazer o mesmo para a table4a e table4b:\n\ntable4_tidy = (table4a.melt(id_vars = \"country\", value_vars = [\"1999\", \"2000\"], var_name = \"year\", value_name = \"cases\")\n                .merge(table4b.melt(id_vars = \"country\", value_vars = [\"1999\", \"2000\"], var_name = \"year\", value_name = \"population\"),\n                       on = (\"country\", \"year\")))\n\ntable4_tidy.assign(rate = lambda _: 10000 * (_.cases / _.population))\n\n       country  year   cases  population      rate\n0  Afghanistan  1999     745    19987071  0.372741\n1       Brazil  1999   37737   172006362  2.193930\n2        China  1999  212258  1272915272  1.667495\n3  Afghanistan  2000    2666    20595360  1.294466\n4       Brazil  2000   80488   174504898  4.612363\n5        China  2000  213766  1280428583  1.669488\n\n\nOs DataFrames table4a e table4b são derretidos usando o método melt:\n\nPara table4a, as colunas que permanecerão fixas são especificadas através do argumento id_vars = “country”, enquanto as colunas “1999” e “2000” são derretidas como variáveis usando value_vars = [“1999”, “2000”]. Os nomes das variáveis derretidas são renomeadas para “year” e “cases” usando var_name = “year” e value_name = “cases”, respectivamente.\nDa mesma forma, para table4b, as colunas “country” e “1999”, “2000” são derretidas, com os nomes das variáveis renomeadas para “year” e “population”, respectivamente.\n\nOs DataFrames resultantes do derretimento de table4a e table4b são mesclados usando o método merge. A mesclagem é feita com base nas colunas “country” e “year”, garantindo que os dados correspondentes de table4a e table4b sejam combinados corretamente.\nFinalmente, o método assign é usado para criar uma nova coluna chamada “rate”, que representa a taxa de casos por 10.000 habitantes.\nPara a table3, basta separar a coluna cases considerando o separador \\:\n\nprint(table3)\n\n       country  year               rate\n0  Afghanistan  1999       745/19987071\n1  Afghanistan  2000      2666/20595360\n2       Brazil  1999    37737/172006362\n3       Brazil  2000    80488/174504898\n4        China  1999  212258/1272915272\n5        China  2000  213766/1280428583\n\ntable3_tidy = (table3.assign(cases = lambda _: _.rate.str.split(\"/\", expand = True)[0].astype(int),\n                       population = lambda _: _.rate.str.split(\"/\",  expand = True)[1].astype(int))\n               .drop(\"rate\", axis = 1))\n\ntable3_tidy\n\n       country  year   cases  population\n0  Afghanistan  1999     745    19987071\n1  Afghanistan  2000    2666    20595360\n2       Brazil  1999   37737   172006362\n3       Brazil  2000   80488   174504898\n4        China  1999  212258  1272915272\n5        China  2000  213766  1280428583\n\ntable3_tidy.assign(rate = lambda _: 10000 * (_.cases / _.population))\n\n       country  year   cases  population      rate\n0  Afghanistan  1999     745    19987071  0.372741\n1  Afghanistan  2000    2666    20595360  1.294466\n2       Brazil  1999   37737   172006362  2.193930\n3       Brazil  2000   80488   174504898  4.612363\n4        China  1999  212258  1272915272  1.667495\n5        China  2000  213766  1280428583  1.669488\n\n\nO parâmetro expand é utilizado no métodostr.split() para especificar se o resultado da divisão deve ser expandido em um DataFrame (se True) ou mantido como uma lista de valores (se False, que é o padrão).\nPrincipais funcionaldiades - ver aulas paulo"
  },
  {
    "objectID": "06-visualizacao_python.html#visualização-de-dados",
    "href": "06-visualizacao_python.html#visualização-de-dados",
    "title": "6  Processamento e visualização de dados",
    "section": "6.6 Visualização de dados",
    "text": "6.6 Visualização de dados\nDuas bibliotecas amplamente utilizadas para visualização em Python são o Matplotlib e o Plotnine. O Matplotlib oferece uma ampla gama de opções para criar visualizações estáticas, desde gráficos simples até gráficos complexos e personalizados. Por outro lado, o Plotnine é uma biblioteca baseada na gramática de gráficos (parecido com o ggplot2 do R), o que facilita a criação de visualizações elegantes e concisas usando uma sintaxe intuitiva e expressiva.\n\n6.6.1 Matplotlib\nAntes de começarmos a criar visualizações, é importante entender alguns conceitos básicos do Matplotlib:\n\nFigura e Eixo (Axes): No Matplotlib, uma figura é a janela ou página na qual tudo é desenhado. Dentro de uma figura, pode haver vários eixos (ou subplots), onde os dados são efetivamente plotados.\nMétodo plot(): O método plot() é usado para criar gráficos de linha, pontos ou marcadores. Ele aceita uma variedade de argumentos para personalizar a aparência do gráfico, como cor, estilo de linha, largura da linha, etc.\nCustomização: O Matplotlib oferece muitas opções de personalização para ajustar a aparência dos gráficos, incluindo a adição de rótulos aos eixos, título do gráfico, legendas, entre outros.\n\nAgora, vamos ver um exemplo de como criar um gráfico de pontos usando dados fictícios, onde cada unidade de dado está relacionada a uma empresa.\n\nimport matplotlib.pyplot as plt\n\n# Dados de exemplo: Nome das empresas, receita e número de funcionários\nempresas = ['A', 'B', 'C', 'D', 'E']\nreceita = [200, 300, 400, 250, 350]  # em milhões de reais\nfuncionarios = [1000, 1200, 1500, 900, 1100]\n\n# Criando o gráfico de pontos\nplt.figure(figsize=(8, 6))\nplt.scatter(receita, funcionarios, color='blue', marker='o')\n\n# Adicionando rótulos e título\nplt.xlabel('Receita (em milhões de reais)')\nplt.ylabel('Número de Funcionários')\nplt.title('Receita vs. Número de Funcionários')\n\n# Adicionando anotações para cada ponto\nfor i in range(len(empresas)):\n    plt.annotate(empresas[i], (receita[i], funcionarios[i]))\n\n# Exibindo o gráfico\nplt.grid(True)\nplt.show()\n\n\n\n\nNeste exemplo, cada ponto no gráfico representa uma empresa, onde o eixo x representa a receita (em milhões de reais) e o eixo y representa o número de funcionários. As anotações são usadas para identificar cada empresa no gráfico.\nNa sequência, utilizamos o Matplotlib para criar um gráfico de linha que representa a evolução das vendas de dois produtos ao longo de vários anos. Cada ponto no gráfico representa o número de vendas em um ano específico.\n\nimport matplotlib.pyplot as plt\n\n# Dados de exemplo: Anos e vendas de produtos\nanos = [2010, 2011, 2012, 2013, 2014, 2015, 2016]\nvendas_produto_A = [500, 600, 550, 700, 800, 750, 900]\nvendas_produto_B = [400, 450, 500, 550, 600, 650, 700]\n\n# Criando o gráfico de linha\nplt.figure(figsize=(10, 6))\nplt.plot(anos, vendas_produto_A, marker='o', label='Produto A')\nplt.plot(anos, vendas_produto_B, marker='s', label='Produto B')\n\n# Adicionando rótulos e título\nplt.xlabel('Ano')\nplt.ylabel('Vendas')\nplt.title('Vendas ao longo do tempo')\n\n# Adicionando legenda\nplt.legend()\n\n# Exibindo o gráfico\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n6.6.2 Plotnine\nPlotnine é uma biblioteca em Python que permite criar visualizações de dados estatísticos de uma forma simples e concisa, utilizando a gramática de gráficos do R (também conhecida como ggplot2). Essa gramática consiste em uma abordagem declarativa para a construção de gráficos, onde os elementos visuais são adicionados em camadas para formar o gráfico final.\n\nfrom plotnine import *\n\nPara exemplificar, vamos utilizar a base de dados gapminder.\n\n((ggplot(gapminder, aes(x = \"continent\", fill = \"continent\")) +\n     geom_bar(aes(y = \"stat(count) / 12\"), alpha = 0.75) +\n     labs(x = \"\", y = \"Number of countries\", title = \"Continents\") +\n     theme(legend_position = \"none\") +\n     coord_flip()+\n     theme_bw())\n     .show())\n\n\n((ggplot(gapminder, aes(x = \"lifeExp\", y = \"stat(density)\")) +\n     geom_histogram(fill = \"blue\", color = \"white\", alpha = 0.5) +\n     labs(x = \"Life Expectancy\", y = \"\", title = \"Gapminder\"))\n     .show())\n\n\n((ggplot(gapminder, aes(x = \"lifeExp\", y = \"stat(density)\")) +\n     geom_histogram(fill = \"blue\", color = \"white\", alpha = 0.5) +\n     labs(x = \"Life Expectancy\", y = \"\", title = \"Gapminder\") +\n     facet_wrap(\"~ continent\", nrow = 1) +\n     theme(figure_size = (12, 2))).\n     show)\n\n\n((gapminder.groupby([\"continent\", \"year\"], as_index = False)\n      .agg(median_lifeExp = (\"lifeExp\", np.median))\n      .pipe(lambda _: ggplot(_, aes(x = \"year\", y = \"median_lifeExp\", color = \"continent\")) +\n                          geom_line(size = 0.75) +\n                          geom_point(size = 1.5) +\n                          labs(x = \"Year\", y = \"Median Life Expectancy\", color = \"Continent\", title = \"Gapminder\")))\n                          .show())"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "McKinney, Wes. 2022. Python for Data Analysis. \" O’Reilly\nMedia, Inc.\".\n\n\nRosling, Hans. 2012. “Data - Gapminder.org.” http://www.gapminder.org/data/.\n\n\nWilkinson, Leland. 2012. The Grammar of Graphics. Springer."
  },
  {
    "objectID": "05-fundamentos_python.html#installation",
    "href": "05-fundamentos_python.html#installation",
    "title": "5  Python Fundamentals",
    "section": "5.1 Installation",
    "text": "5.1 Installation\nFollow the steps below to install Anaconda and JupyterLab:\n\nDownload and install Anaconda from the official website. Follow the installation instructions for your specific operating system.\nAfter installing Anaconda, open the Anaconda Navigator and create a new virtual environment. Navigate to the “Environments” section and click “Create” to add a new environment. Name the environment and choose the Python version you want to use.\nAfter creating the virtual environment, activate it by clicking on the newly created environment in the list of environments and selecting “Open Terminal”. In the terminal, type the command conda activate your_environment_name (replace your_environment_name with the name of the environment you created).\nWith the virtual environment activated, install JupyterLab by typing conda install jupyterlab in the terminal.\nAfter installing JupyterLab, run it by typing jupyter lab in the terminal or through the Anaconda interface. This will open JupyterLab in your default browser.\nIn JupyterLab, you can create a new Python notebook by clicking the “+” icon in the left sidebar and selecting “Python 3” under the “Notebook” header."
  },
  {
    "objectID": "05-fundamentos_python.html#fundamental-data-types",
    "href": "05-fundamentos_python.html#fundamental-data-types",
    "title": "5  Python Fundamentals",
    "section": "5.2 Fundamental data Types",
    "text": "5.2 Fundamental data Types\nIn Python, the fundamental data types include integer, float, string, and boolean:\n\nIntegers are whole numbers, such as 1, 2, -3, etc.\nFloats are decimal numbers, such as 3.14, -0.5, etc.\nStrings are sequences of characters, such as “hello”, “world”, “python”, etc.\nBooleans are logical values that represent true (True) or false (False).\n\nThese data types are the basic building blocks for representing different types of information in Python, and are widely used in programming to perform operations and data manipulations.\n\n5.2.1 The Integer data type\nAn integer data type (integer) in Python represents whole numbers, i.e., numbers without decimal places. For example, 5, -10, and 0 are all examples of integers. In Python, integers are represented by the int class. In the examples below, we perform basic operations with integers.\n\n2 + 2  \n\n4\n\n\nIn the first line, we calculate the sum of 2 and 2.\n\nquantity = 200\nprint(quantity)\n\n200\n\ntype(quantity)\n\n&lt;class 'int'&gt;\n\n\nAbove, we assign the value 200 to the variable quantity and print it using print(quantity). Finally, we check the data type of the variable quantity with type(quantity), which returns &lt;class 'int'&gt;, indicating that it is an integer.\n\n\n5.2.2 The Float data Type\nA float data type (float) in Python represents decimal numbers, i.e., numbers that can have a fractional part. For example, 3.14, -0.001, and 2.71828 are all floats. In Python, floats are represented by the float class.\n\n1.75 + 2**3 \n\n9.75\n\ninterest_rate = 1.25\n\nprint(interest_rate)\n\n1.25\n\ntype(interest_rate)\n\n&lt;class 'float'&gt;\n\n\nIn the first line of the example above, we calculated the sum of 1.75 and 2 raised to the power of 3. Then, we assigned the value 1.25 to the variable interest_rate and print it using print(interest_rate). Finally, we checked the data type of the variable interest_rate with type(interest_rate), which returned &lt;class 'float'&gt;, indicating that it is a float.\n\n\n5.2.3 The String data Type\n\ncountry = \"Brazil\" \n\nprint(country)\n\nBrazil\n\ntype(country)\n\n&lt;class 'str'&gt;\n\n\nIn the code above, we created a variable called country and assigned it the value “Brazil”, which was a string. Then, we printed the value of the variable country using print(country), which displayed “Brazil” on the screen. Finally, we checked the data type of the variable country with type(country), which returned &lt;class 'str'&gt;, indicating that it was a string.\n\n\n5.2.4 The Boolean data Type\nThe boolean data type, also known as bool, is used to represent true or false values. In Python, the boolean values are True and False.\n\n1 == 2\n\nFalse\n\n\n\n5 % 2 == 0\n\nFalse\n\n\n\ninterest_rate_increasing = True\nprint(interest_rate_increasing)\n\nTrue\n\ntype(interest_rate_increasing)\n\n&lt;class 'bool'&gt;\n\n\nIn the first line of the example above, there is an equality check between 1 and 2, which returns False because 1 is not equal to 2. Next, we have 5 % 2 == 0, which also returns False because the remainder of 5 divided by 2 is not equal to zero. Finally, we have the variable interest_rate_increasing assigned to True, indicating that the interest rate is increasing. When printing and checking the type of this variable, we get True as the result and the type bool, indicating that it is a boolean value.\n\n\n5.2.5 Type Coercion\nType coercion in Python refers to the forced conversion of one data type to another.\n\nstr_num = \"1.41\"\ntype(str_num)\n\n&lt;class 'str'&gt;\n\n\n\nfloat(str_num)\n\n1.41\n\n\nNote that the variable str_num is a string representing the number 1.41. Initially, its type is checked using the type function, which returns &lt;class 'str'&gt;, indicating that it is a string. Then, we use the float() function to explicitly convert str_num to a float. After the conversion, the value of str_num is “1.41” and its type is changed to &lt;class 'float'&gt;.\nBelow are other examples of coercion.\nCoercion to integer:\n\nnum_float = 3.14\nnum_int = int(num_float)\nprint(num_int)\n\n3\n\n\nCoercion to boolean:\n\nint_value = 0\nbool_value = bool(int_value)\nprint(bool_value)\n\nFalse\n\n\nCoercion to string (str):\n\nnum_float = 3.14\nnum_str = str(num_float)\nprint(num_str) \n\n3.14\n\n\nIn the code above, we are coercing a float value to a string."
  },
  {
    "objectID": "05-fundamentos_python.html#basic-objects",
    "href": "05-fundamentos_python.html#basic-objects",
    "title": "5  Python Fundamentals",
    "section": "5.3 Basic Objects",
    "text": "5.3 Basic Objects\nIn Python, there are three basic data structures: lists, tuples, and dictionaries:\n\nLists are ordered and mutable collections of elements, allowing the inclusion of items of different types and the modification of the values contained in them.\nTuples are similar to lists, but they are immutable, meaning they cannot be changed after creation.\nDictionaries are unordered collections of key-value pairs, where each value is associated with a unique key, providing efficient access to data through the keys.\n\n\n5.3.1 Lists\nIn Python, a list is a data structure that allows storing an ordered collection of elements. To create a list, we use square brackets [], and the elements are separated by commas. We can instantiate an empty list simply by using [] or the list() function. For example:\n\nempty_list = [] # Empty list\nempty_list = list() # alternative\n\n# list with GDP of countries\ngdp_countries = [1800, 2500, 3200, 5600, 6700]\n\nIn the example above, we also have the list gdp_countries that stores the Gross Domestic Product (GDP) of different countries. To access elements of a list in Python, we can use the index of the desired element within square brackets []. The index starts at zero for the first element, one for the second, and so on. For example:\n\nprint(gdp_countries[1])\n\n2500\n\n\nWe can also access elements from the end of the list using negative indices, where -1 represents the last element, -2 the second last, and so on:\n\n# Accessing the last element\nlast_element = gdp_countries[-1]\nprint(last_element)\n\n6700\n\n# Accessing the second last element\nsecond_last_element = gdp_countries[-2]\nprint(second_last_element)\n\n5600\n\n\nWe can use the append() method if we want to add an element to the end of the list, or the insert() method if we want to add an element at a specific position. See the examples of how to use both methods:\n\n# Adding elements to the end of the list using append()\ngdp_countries.append(2000)  # Adds the value 2000 to the end of the list\n\n# Adding an element at a specific position using insert()\ngdp_countries.insert(1, 1500)  # Adds the value 1500 at position 1 of the list\n\nTo check the size of a list in Python, we can use the len() function.\n\nlist_size = len(gdp_countries)\nprint(\"List size:\", list_size) \n\nList size: 7\n\n\nTo sort a list, we can use the sort() method for in-place sorting (i.e., the list is modified) or the sorted() function to return a new sorted list without modifying the original:\n\n# Using the sorted() function to return a new sorted list\nsorted_list = sorted(gdp_countries)\nprint(\"New sorted list:\", sorted_list)\n\nNew sorted list: [1500, 1800, 2000, 2500, 3200, 5600, 6700]\n\n# Sorting the list using the sort() method\ngdp_countries.sort()\nprint(\"Sorted list:\", gdp_countries)\n\nSorted list: [1500, 1800, 2000, 2500, 3200, 5600, 6700]\n\n\nThe .pop() method is used to remove and return the last element of a list. We can also specify an index to remove and return an element at a specific position in the list. Here’s how to use the .pop() method:\n\n# Removing and returning the last GDP from the list\nlast_gdp = gdp_countries.pop()\nprint(\"Last GDP removed:\", last_gdp) \n\nLast GDP removed: 6700\n\nprint(\"Updatad list:\", gdp_countries)\n\nUpdatad list: [1500, 1800, 2000, 2500, 3200, 5600]\n\n# Removing and returning the GDP of a specific country from the list\nremoved_gdp = gdp_countries.pop(1) \nprint(\"GDP removed:\", removed_gdp) \n\nGDP removed: 1800\n\nprint(\"Updatad list:\", gdp_countries)\n\nUpdatad list: [1500, 2000, 2500, 3200, 5600]\n\n\n\n\n5.3.2 Tuples\nTuples are data structures similar to lists, but with a fundamental difference: they are immutable, meaning once created, they cannot be modified. They are represented by parentheses () instead of square brackets [].\n\nx = (1, 2, 3) # tuple (immutable list)\nprint(x)\n\n(1, 2, 3)\n\n\n# x[0] = 5 # generates an error!\n\nWe can use tuples to represent information that should not be changed, such as exchange rates between currencies. See:\n\nexchange_rates = ((\"USD\", \"EUR\", 0.82), (\"USD\", \"JPY\", 105.42), (\"EUR\", \"JPY\", 128.64))\n\nIn this example, we have a tuple of tuples representing the exchange rates between the US dollar (USD), the euro (EUR), and the Japanese yen (JPY) for a fixed fictitious data. Each inner tuple contains three elements: the source currency, the target currency, and the exchange rate. Since this information should not be changed, a tuple is an appropriate choice.\n\n\n\n\n\n\nTip\n\n\n\nTo access the elements of a tuple, you can use the same syntax you use to access the elements of a list, i.e., using square brackets [] and the index of the desired element. Remember that indices in Python start at 0!\n\n\n\n\n5.3.3 Dictionaries\nDictionaries in Python are data structures that allow storing key-value pairs. Each value is associated with a specific key, allowing quick access to data through the keys, rather than numerical indices, as in lists and tuples. This structure is useful when you need to associate information in a way similar to a database, where you can search for information based on a specific key.\nIn the example below, we have share quotes of some Brazilian companies listed on the share exchange.\n\nbrazilian_share_quotes = {\n    \"PETR4\": 36.75,\n    \"VALE3\": 62.40,\n    \"ITUB4\": 34.15,\n    \"BBDC4\": 13.82\n}\n\nEach key is the share ticker symbol, and the associated value is the share price on a fixed data. For example, brazilian_share_quotes[\"PETR4\"] would return the price of Petrobras share.\nAlternatively, you can create a dictionary using the dict function:\n\nbrazilian_share_quotes = dict(PETR4=36.12, VALE3=62.40, ITUB4=34.15, BBDC4=13.82)\n\nYou can add new key-value pairs to a dictionary or update existing values. For example:\n\nbrazilian_share_quotes[\"ABEV3\"] = 12.80\nbrazilian_share_quotes[\"PETR4\"] = 36.75\n\nYou can remove key-value pairs from a dictionary using the pop() method. For example:\n\nremoved_value = brazilian_share_quotes.pop(\"BBDC4\")\n\nOther useful methods for working with dictionaries are keys(), values(), and items() which return lists with the keys, values, and items of the dictionary, respectively.\n\nbrazilian_share_quotes.keys() # returns a list containing all the keys\n\ndict_keys(['PETR4', 'VALE3', 'ITUB4', 'ABEV3'])\n\n\n\nbrazilian_share_quotes.values() # returns a list containing all the values\n\ndict_values([36.75, 62.4, 34.15, 12.8])\n\n\n\nbrazilian_share_quotes.items() # returns a list of tuples\n\ndict_items([('PETR4', 36.75), ('VALE3', 62.4), ('ITUB4', 34.15), ('ABEV3', 12.8)])"
  },
  {
    "objectID": "05-fundamentos_python.html#slices",
    "href": "05-fundamentos_python.html#slices",
    "title": "5  Python Fundamentals",
    "section": "5.4 Slices",
    "text": "5.4 Slices\nThe concept of slices, also known as “slicing”, refers to the technique of extracting specific parts of a sequence, such as a list, tuple, or string, using indices. By using slices, you can select a range of elements within the sequence.\nThe basic syntax for slices is sequence[start:stop:step], where:\n\nstart: the starting index of the range to be included in the slice (inclusive).\nstop: the ending index of the range to be included in the slice (exclusive).\nstep: the step size between selected elements (optional).\n\nConsider the list below.\n\ncountry_names = [\"Indonesia\", \"India\", \"Brazil\", \"South Africa\", \"Germany\"]\n\nTo access the first three countries, we can do:\n\ncountry_names[:3]\n\n['Indonesia', 'India', 'Brazil']\n\n\nThis returns the elements of the list from index 0 (inclusive) to index 3 (exclusive).\nIf we want to access the countries from the second to the third:\n\ncountry_names[1:4]\n\n['India', 'Brazil', 'South Africa']\n\n\nWe can even make reverse slices, where the starting index is greater than the ending index, indicating that we want to traverse the list from back to front. For example, to access the last three countries:\n\ncountry_names[-3:]\n\n['Brazil', 'South Africa', 'Germany']\n\n\nSuppose we want to access all countries, but skipping every two:\n\ncountry_names[::2]\n\n['Indonesia', 'Brazil', 'Germany']\n\n\nIn this example, ::2 indicates that we want to start from the beginning of the list and go to the end, skipping every two elements."
  },
  {
    "objectID": "05-fundamentos_python.html#conditionals",
    "href": "05-fundamentos_python.html#conditionals",
    "title": "5  Python Fundamentals",
    "section": "5.5 Conditionals",
    "text": "5.5 Conditionals\nThe if and else are control flow structures in Python, used to make decisions based on conditions.\nThe block of code inside the if is executed if the condition evaluates to true (True). For example:\n\nage = 18\nif age &gt;= 18:\n    print(\"You are of legal age.\")\n\nYou are of legal age.\n\n\nThe block of code inside the else is executed if the condition of the if evaluates to false (False). For example:\n\nage = 16\nif age &gt;= 18:\n    print(\"You are of legal age.\")\nelse:\n    print(\"You are underage.\")\n\nYou are underage.\n\n\n\n\n\n\n\n\nIndentation\n\n\n\nIn Python, indentation is crucial for defining code blocks. In the example above, notice that the code inside the if and else is indented with four spaces. This indicates that these lines belong to the conditional code block. If there is no proper indentation, Python will raise a syntax error."
  },
  {
    "objectID": "05-fundamentos_python.html#loop-structures",
    "href": "05-fundamentos_python.html#loop-structures",
    "title": "5  Python Fundamentals",
    "section": "5.6 Loop Structures",
    "text": "5.6 Loop Structures\nRepetition structures are used to execute a block of code repeatedly based on a specific condition. There are two main repetition structures in Python: for and while.\n\n5.6.1 for\nThe for loop is used to iterate over a sequence (such as a list, tuple, dictionary, etc.) and execute a block of code for each item in the sequence. For example:\n\nfor x in range(0, 20, 3):  # remember slice notation\n    print(x)\n\n0\n3\n6\n9\n12\n15\n18\n\n\n\nfor country in country_names:\n    print(\"Country:\", country)\n\nCountry: Indonesia\nCountry: India\nCountry: Brazil\nCountry: South Africa\nCountry: Germany\n\n\nIn the example below, we have a list of companies and a list of profits. Using the zip() function, we iterate over these two lists in parallel, printing the company name and its corresponding profit. The zip() function combines elements from two or more sequences (like lists, tuples, etc.) into ordered pairs.\n\ncompanies = [\"Company A\", \"Company B\", \"Company C\"]\nprofits = [100000, 150000, 80000]\n\nfor company, profit in zip(companies, profits):\n    print(\"The profit of\", company, \"was R$\", profit)\n\nThe profit of Company A was R$ 100000\nThe profit of Company B was R$ 150000\nThe profit of Company C was R$ 80000\n\n\n\n\n5.6.2 while\nThe while loop is a control flow structure that executes a block of code repeatedly while a specified condition is true.\n\nyears = 1\ninvestment = 1000\nreturn_rate = 0.05\n\nwhile years &lt;= 10:\n    investment *= (1 + return_rate)\n    print(\"After\", years, \"years, the investment is worth R$\", round(investment, 2))\n    years += 1\n\nAfter 1 years, the investment is worth R$ 1050.0\nAfter 2 years, the investment is worth R$ 1102.5\nAfter 3 years, the investment is worth R$ 1157.62\nAfter 4 years, the investment is worth R$ 1215.51\nAfter 5 years, the investment is worth R$ 1276.28\nAfter 6 years, the investment is worth R$ 1340.1\nAfter 7 years, the investment is worth R$ 1407.1\nAfter 8 years, the investment is worth R$ 1477.46\nAfter 9 years, the investment is worth R$ 1551.33\nAfter 10 years, the investment is worth R$ 1628.89\n\n\nIn this example, the loop calculates the value of the investment over 10 years, considering an annual return of 5%. In each iteration, the investment value is updatad by multiplying by the growth factor (1 + return_rate)."
  },
  {
    "objectID": "05-fundamentos_python.html#functions",
    "href": "05-fundamentos_python.html#functions",
    "title": "5  Python Fundamentals",
    "section": "5.8 Functions",
    "text": "5.8 Functions\nFunctions are reusable code blocks that perform a specific task. They accept inputs, called arguments, and can return results.\nIn Python, the basic syntax of a function is as follows:\n\ndef function_name(argument1, argument2, ...):\n    # Function body\n    # Do something with the arguments\n    result = argument1 + argument2\n    return result\n\nFor example, let’s create a function in Python called calculate_interest that calculates the final amount of an investment based on the initial value, the interest rate, and the number of years:\n\ndef calculate_interest(initial_value, interest_rate, years):\n    final_amount = initial_value * (1 + interest_rate) ** years\n    return final_amount\n\nNow, let’s define values and call the function:\n\ninitial_investment = 1000  # Initial investment value\nannual_interest_rate = 0.05  # Annual interest rate (5%)\nyears = 5  # Number of years\nresult = calculate_interest(initial_investment, annual_interest_rate, years)\nprint(\"The final amount after\", years, \"years will be: R$\", round(result, 2))\n\nThe final amount after 5 years will be: R$ 1276.28\n\n\n\n5.8.1 lambda Function\nA lambda function in Python is an anonymous function, which means it is a function without a name. It is defined using the keyword lambda and can have any number of arguments but only one expression. The basic syntax is as follows:\n\nlambda argument1, argument2, ...: expression\n\nSee an example of a lambda function that calculates the square of a number:\n\nsquare = lambda x: x ** 2\n\nIn this example, lambda x: x ** 2 creates a function that accepts an argument x and returns x squared. You can then use this function the same way as any other function. For example:\n\nresult = square(5)\nprint(result)\n\n25\n\n\nLambda functions are often used in situations where you need a temporary and simple function, such as in mapping, filtering, and sorting operations."
  },
  {
    "objectID": "05-fundamentos_python.html#classes-and-objects",
    "href": "05-fundamentos_python.html#classes-and-objects",
    "title": "5  Python Fundamentals",
    "section": "5.9 Classes and Objects",
    "text": "5.9 Classes and Objects\nA class is a structure that defines the behavior and properties of a type of object. We can think of a class as a representation of an abstract concept, such as a financial transaction or a specific type of investment.\nFor example, we can create a class called Transaction to represent a financial transaction, with properties such as the transaction amount, data, and transaction type.\nAn object, on the other hand, is a specific instance of a class. It represents a concrete entity with its own characteristics and behaviors. Continuing with the Transaction class example, we can create individual objects to represent specific transactions, such as buying shares of a company on a certain data.\n\nclass Transaction:\n    def __init__(self, value, data, type):\n        self.value = value\n        self.data = data\n        self.type = type\n    \n    def print_info(self):\n      print(f\"Transaction type: {self.type}, Value: R${self.value}, data: {self.data}\")\n\nIn this example, the Transaction class has a special method __init__ that is called when a new object is created. This method initializes the object’s properties with the values provided as arguments. Additionally, the class has a method called print_info, which prints transaction information, including the type, value, and data. This method also receives self as a parameter to access the current instance’s attributes. By calling print_info() on a Transaction object, it will display the formatted transaction information.\nBelow, we create two objects of the Transaction class, transaction1 and transaction2, and access their properties to obtain information about the transactions.\n\n# Creating objects of the Transaction class\ntransaction1 = Transaction(value=1000, data=\"2024-03-11\", type=\"share purchase\")\ntransaction2 = Transaction(value=500, data=\"2024-03-12\", type=\"share sale\")\n\n# Accessing object properties\nprint(\"Transaction 1 value:\", transaction1.value)\n\nTransaction 1 value: 1000\n\nprint(\"Transaction 2 data:\", transaction2.data)\n\nTransaction 2 data: 2024-03-12\n\n# Accessing object methods\ntransaction1.print_info()\n\nTransaction type: share purchase, Value: R$1000, data: 2024-03-11\n\ntransaction2.print_info()\n\nTransaction type: share sale, Value: R$500, data: 2024-03-12"
  },
  {
    "objectID": "05-fundamentos_python.html#exercises",
    "href": "05-fundamentos_python.html#exercises",
    "title": "5  Python Fundamentals",
    "section": "5.10 Exercises",
    "text": "5.10 Exercises\n1. Working with basic data types\na) Create variables to represent economic data, such as the GDP of at least three countries, inflation rates, or unemployment rates. Use recent and historical values to create a diverse set of economic data representing different economic contexts around the world.\nb) Perform basic mathematical operations with this data, such as calculating averages, growth rates, or proportions. For example, you can calculate GDP value averages, GDP growth rates over time, and proportions between different economic indicators (such as per capita GDP relative to total GDP), among other operations.\n2. During data analysis, it may be necessary to convert between different data types. Use fundamental data types (integers, floats, strings) and apply type coercion as needed. Consider, for instance, that the variables representing GDP were given in string format. Then, convert to a float type to compute the average of the GDP values considered. After that, convert the GDP values back to a string for output formatting in the following format: 1,111%.\n3. Use the code below to generate a pandas dataFrame that represents the closing price of a share:\nimport pandas as pd\n\n# Creating a list of dates\ndates = pd.date_range(start='2023-01-01', end='2023-12-31', freq='B')  # Frequency 'B' to consider only business days\n\n# Creating a series of simulated closing prices\nimport numpy as np\nnp.random.seed(0)  # Set the random seed for reproducibility\nclosing_prices = np.random.normal(loc=50, scale=5, size=len(datas))  # Simulating prices with a normal distribution\n\n# Creating the dataFrame\ndf_share_prices = pd.dataFrame({'date': dates, 'Closing Price': closing_prices})\n\n# Displaying the first few rows of the dataFrame\nprint(df_share_prices.head())\na) Obtain the share closing prices during the specified month of January.\nb) Obtain the share closing prices between 2023-06-01 and 2023-12-31.\nc) Obtain the share closing prices on Fridays throughout the entire period. Calculate the average closing price on Mondays and compare it to Fridays. Which one has a higher standard deviation?\n# Creating a column to store the day of the week\ndf_share_prices['Day of the Week'] = df_share_prices['date'].dt.weekday\n\n# Displaying the first few rows of the dataFrame with the new column\nprint(df_share_prices.head())\n4. Consider the list stored in the variable gdp_years below and use a list comprehension to calculate the GDP growth percentage relative to the previous year for each country.\n# List of GDP values for a country over the last five years\ngdp_years = [1000, 1200, 800, 1500, 2000]  # Example fictitious GDP values\n#| eval: false\n#| echo: false\n# List comprehension to calculate GDP growth percentage relative to the previous year for each country\ngdp_growth = [(current / previous - 1) * 100 for current, previous in zip(gdp_years[1:], gdp_years[:-1])]\nprint(\"GDP growth percentage relative to the previous year:\")\nfor i, growth in enumerate(gdp_growth):\n    print(f\"Country {i + 2}: {growth:.2f}%\")\n5. Write a function called calculate_pci that takes three arguments:\n\nproduct_basket: A dictionary mapping each product to its quantity in the basket.\n\ncurrent_price: A dictionary mapping each product to its current price.\n\nreference_price: A dictionary mapping each product to its base price (reference price). The Consumer Price Index (CPI) is calculated using the following formula: \\[PCI = \\sum_i \\frac{\\text{current price of product}_i}{\\text{reference price of product}_i} \\times \\text{product quantity}_i.\\] The function should return the calculated PCI value. Use the code below to test your function.\n\n#| eval: false\n#| echo: false\ndef calculate_pci(product_basket, current_price, reference_price):\n    pci = 0\n    for produto, preco_atual in current_price.items():\n        preco_base = reference_price[produto]\n        pci += (preco_atual / preco_base) * product_basket[produto]\n    return pci\n\n# Usage example of the calculate_pci function\nproduct_basket = {'rice': 1, 'beans': 2, 'meat': 3}  # Basket of products with their respective quantities\ncurrent_price = {'rice': 5, 'beans': 8, 'meat': 12}      # Current prices of products\nreference_price = {'rice': 4, 'beans': 7, 'meat': 10}      # Reference prices of products\n\npci = calculate_pci(product_basket, current_price, reference_price)\nprint(\"The Consumer Price Index (CPI) is:\", pci)\n\n# Basket of products with their respective quantities\nproduct_basket = {'rice': 1, 'beans': 2, 'meat': 3}  \n# Current prices of the products\ncurrent_price = {'rice': 5, 'beans': 8, 'meat': 12}      \n# Reference prices of the products\nreference_price = {'rice': 4, 'beans': 7, 'meat': 10}      \n\n# Call the function to calculate the pci\npci = calculate_pci(product_basket, current_price, reference_price)\nprint(\"The Consumer Price Index (IPC) is:\", pci)\n\n6. You are tasked with developing a system to record and manage share buy and sell transactions, as well as calculate important information about the investment portfolio. For this, you must implement two Python classes: Transaction and Portfolio.\nThe transaction class represents a single share buy or sell transaction. It has the following attributes:\n\ndate: a string representing the transaction date in the format ‘YYYY-MM-DD’.\n\ntype: a string indicating the transaction type, which can be ‘buy’ or ‘sell’.\n\nvalue: an integer representing the number of shares transacted.\n\nThe Portfolio class represents the user’s investment portfolio, which contains several share transactions. It has the following attributes:\n\ntransactions: a list that stores all the share transactions performed.\n\nAdditionally, the Portfolio class has the following methods:\n\nadd_transaction(transaction): adds a new transaction to the portfolio.\n\ncalculate_current_position(current_share_price): calculates the current share position in the portfolio based on the current share price.\n\ncalculate_present_value(current_share_price): calculates the present value of the share in the portfolio based on the current share price.\n\n#| eval: false\n#| echo: false\nclass transaction:\n    def __init__(self, date, type, value):\n        self.date = date\n        self.type = type  # 'buy' or 'sell'\n        self.value = value\n\nclass Portfolio:\n    def __init__(self):\n        self.transactions = []\n\n    def add_transaction(self, transaction):\n        self.transactions.append(transaction)\n\n    def calculate_current_position(self, current_share_price):\n        n_shares = 0\n        for transaction in self.transactions:\n            if transaction.type == 'buy':\n                n_shares += transaction.value\n            elif transaction.type == 'sell':\n                n_shares -= transaction.value\n        return n_shares\n\n    def calculate_present_value(self, current_share_price):\n        current_position = self.calculate_current_position(current_share_price)\n        present_value = current_position * current_share_price\n        return present_value\n\n# Example usage of the classes\n\n# Creating some transactions\ntransaction1 = transaction('2024-03-18', 'buy', 10)  # Buy 10 shares\ntransaction2 = transaction('2024-03-19', 'buy', 5)   # Buy 5 more shares\ntransaction3 = transaction('2024-03-20', 'sell', 8)    # Sell 8 shares\n\n# Creating a portfolio and adding transactions\nPortfolio = Portfolio()\nPortfolio.add_transaction(transaction1)\nPortfolio.add_transaction(transaction2)\nPortfolio.add_transaction(transaction3)\n\n# Current share value\ncurrent_share_price = 50  # Hypothetical share value\n\n# Calculating the current position and present value in the portfolio\ncurrent_position = Portfolio.calculate_current_position(current_share_price)\npresent_value = Portfolio.calculate_present_value(current_share_price)\n\nprint(\"Current share position in the portfolio:\", current_position)\nprint(\"Present value in the portfolio:\", present_value)\na) Implement the transaction and Portfolio classes with the attributes and methods described above.\nb) Create three instances of the transaction class to represent different share buy and sell transactions.\nc) Create an instance of the Portfolio class and add the created transactions to the portfolio.\nd) Test the methods of the Portfolio class using the examples provided in the test code above.\n\n# Creating some transactions\ntransaction1 = transaction('2024-03-18', 'buy', 10)  # Buy 10 shares\ntransaction2 = transaction('2024-03-19', 'buy', 5)   # Buy 5 more shares\ntransaction3 = transaction('2024-03-20', 'sell', 8)    # Sell 8 shares\n\n# Creating a portfolio and adding transactions\nPortfolio = Portfolio()\nPortfolio.add_transaction(transaction1)\nPortfolio.add_transaction(transaction2)\nPortfolio.add_transaction(transaction3)\n\n# Current share value\ncurrent_share_price = 50  # Hypothetical share value\n\n# Testing the methods of the Portfolio class\ncurrent_position = Portfolio.calculate_current_position(current_share_price)\npresent_value = Portfolio.calculate_present_value(current_share_price)\n\n# Exibindo os resultados\nprint(\"Current share position in the Portfolio:\", current_position)\nprint(\"Present value in the Portfolio:\", present_value)\n\n\n\n\n\nMcKinney, Wes. 2022. Python for Data Analysis. \" O’Reilly Media, Inc.\"."
  },
  {
    "objectID": "06-visualizacao_python.html#library-installation",
    "href": "06-visualizacao_python.html#library-installation",
    "title": "6  Data Processing and Visualization",
    "section": "6.1 Library Installation",
    "text": "6.1 Library Installation\nInstalling libraries in Python is essential to expand the language’s functionality. There are several ways to install libraries, but the most common is using a package manager. Pip is the default package manager for Python and usually comes with the Python installation.\nTo install a library with pip, open the terminal or command prompt and type the following command:\n\npip install library_name\n\nReplace library_name with the name of the library you want to install."
  },
  {
    "objectID": "06-visualizacao_python.html#numerical-data-processing",
    "href": "06-visualizacao_python.html#numerical-data-processing",
    "title": "6  Data Processing and Visualization",
    "section": "6.2 Numerical Data Processing",
    "text": "6.2 Numerical Data Processing\nNumPy (Numerical Python) is an essential library for numerical computing in Python. It provides efficient data structures for working with multidimensional arrays and powerful mathematical functions for data manipulation.\nTo install NumPy, you can use pip, the default Python package manager:\n\npip install numpy\n\nThe main object in NumPy is the multidimensional array. You can create NumPy arrays using the numpy.array() function and perform basic mathematical operations with them:\n\nimport numpy as np\n\n# Creating a NumPy array\narr = np.array([1, 2, 3, 4, 5])\n\n# Basic mathematical operations\nprint(\"Sum:\", np.sum(arr))\n\nSum: 15\n\nprint(\"Mean:\", np.mean(arr))\n\nMean: 3.0\n\n\nIn addition to basic operations, NumPy provides universal functions (ufuncs) to apply operations to all elements of an array at once:\n\n# Universal functions (ufuncs)\narr = np.array([1, 2, 3, 4, 5])\nprint(\"Square of each element:\", np.square(arr))\n\nSquare of each element: [ 1  4  9 16 25]\n\nprint(\"Exponential of each element:\", np.exp(arr))\n\nExponential of each element: [  2.71828183   7.3890561   20.08553692  54.59815003 148.4131591 ]\n\n\nNext, we present three practical examples of using NumPy functions.\nExample 1: Descriptive Statistics Calculation\nNumPy can be used to calculate descriptive statistics, such as mean, median, standard deviation, minimum, and maximum of time series data, such as the stock price of a company over time.\n\nimport numpy as np\n\n# Stock price of a company over time (in dollars)\nprices = np.array([100, 102, 105, 110, 108, 115, 120])\n\n# Calculating descriptive statistics\nprint(\"Mean:\", np.mean(prices))\n\nMean: 108.57142857142857\n\nprint(\"Standard deviation:\", np.std(prices))\n\nStandard deviation: 6.58693821908486\n\nprint(\"Maximum:\", np.max(prices))\n\nMaximum: 120\n\nprint(\"Minimum:\", np.min(prices))\n\nMinimum: 100\n\n\nExample 2: Time Series Analysis NumPy is useful for time series manipulation and analysis. For example, you can use NumPy to calculate the return rate of an investment over time or to smooth a time series using moving averages.\n\nprices = np.array([100, 102, 105, 110, 108, 115, 120])\n# Calculating the return rate of an investment over time\nreturns = np.diff(prices) / prices[:-1] * 100\nprint(\"Return rate:\", returns)\n\nReturn rate: [ 2.          2.94117647  4.76190476 -1.81818182  6.48148148  4.34782609]\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe np.diff function in NumPy is used to calculate the difference between consecutive elements along a specified axis of an array. Note: The size of the output from the np.diff function will always be one less than the size of the original input vector. For example, if we have a one-dimensional vector with \\(n\\) elements, the np.diff function will return a vector with \\(n−1\\) elements, as there is no difference for the last element.\n\n\n\nprices = np.array([100, 102, 105, 110, 108, 115, 120])\n# Smoothing a time series using moving averages\nwindow_size = 3\nmoving_average = np.convolve(prices, np.ones(window_size) / window_size, mode='valid')\nprint(\"Moving averages:\", moving_average)\n\nMoving averages: [102.33333333 105.66666667 107.66666667 111.         114.33333333]\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe np.convolve function in NumPy is used to perform convolution between two sequences, represented by two one-dimensional vectors. Convolution is a mathematical operation that combines two functions to produce a third function that represents the amount of overlap between them as one is shifted along the axis.\nThe basic syntax of the function is np.convolve(a, b, mode='full'), where a and b are the two one-dimensional vectors to be convolved, and mode is an optional parameter that defines the convolution mode. The most common modes are:\n\n'full': Returns the full output of the convolution. The length of the result will be len(a) + len(b) - 1.\n'valid': Returns only points where the sequences fully overlap. The length of the result will be max(len(a), len(b)) - min(len(a), len(b)) + 1.\n'same': Returns output of the same size as the longest input vector. The length of the result will be max(len(a), len(b)).\n\nIn the previous example, the np.convolve function was used here to calculate the moving average of prices. In this case, the first sequence is the price vector, and the second sequence is a vector of 1s divided by the moving average window size. This creates a sequence that represents a weighted average of the values.\n\n\nExample 3: Monte Carlo Simulation NumPy can be used to perform Monte Carlo simulations, which are widely used in financial modeling and risk assessment. For example, you can simulate the performance of an investment portfolio over time under different market scenarios.\n\n# Monte Carlo simulation of an investment portfolio's performance\nnum_simulations = 1000\nnum_years = 10\nmean_return = 0.08\nvolatility = 0.15\n\n# Generating random returns using a normal distribution\nreturns = np.random.normal(mean_return, volatility, size=(num_simulations, num_years))\n\n# Calculating the final portfolio value for each simulation\ninitial_investment = 10000\nfinal_values = initial_investment * np.cumprod(1 + returns, axis=1)\n\n# Descriptive statistics of the final portfolio values\nprint(\"Mean final value:\", np.mean(final_values[:,-1]))\n\nMean final value: 21419.40917776627\n\nprint(\"Standard deviation of final values:\", np.std(final_values[:,-1]))\n\nStandard deviation of final values: 10252.053756660043\n\n\nMore references on NumPy:\n\nOfficial NumPy Documentation: https://numpy.org/doc/stable/ The official NumPy documentation contains detailed information on all available functions and methods, as well as tutorials and examples.\nNumPy Quickstart Tutorial: https://numpy.org/doc/stable/user/quickstart.html This quickstart tutorial provides a quick introduction to NumPy and its basic functionalities."
  },
  {
    "objectID": "06-visualizacao_python.html#data-analysis-and-processing",
    "href": "06-visualizacao_python.html#data-analysis-and-processing",
    "title": "6  Data Processing and Visualization",
    "section": "6.3 Data Analysis and Processing",
    "text": "6.3 Data Analysis and Processing\nPandas is a widely used open-source library in Python for data analysis and manipulation. It provides flexible data structures and powerful tools for working with structured data, facilitating data analysis, cleaning, and preparation for various applications, such as data science, finance, academic research, and more."
  },
  {
    "objectID": "06-visualizacao_python.html#what-is-pandas",
    "href": "06-visualizacao_python.html#what-is-pandas",
    "title": "6  Data Processing and Visualization",
    "section": "6.4 What is Pandas?",
    "text": "6.4 What is Pandas?\nPandas is an open-source Python library that offers high-performance data structures and data analysis tools. Pandas is designed to handle the complexities of real-world data analysis, offering a simple and intuitive interface for working with tabular data.\nPandas is widely used in data analysis due to its ability to:\n\nImport and export data from a variety of sources, including CSV, Excel, SQL, JSON, HDF5 files, and more.\nEfficiently manipulate data, including indexing, filtering, aggregation, and cleaning.\nPerform statistical and mathematical operations on data, such as mean, sum, standard deviation, correlation, etc.\n\nThe two main data structures provided by Pandas are Series and DataFrames.\n\n6.4.1 Series\nA Series is a one-dimensional data structure that can contain any type of data, such as integers, floats, strings, among others. Each element in a Series has a unique label called an index. The Series is similar to a list or one-dimensional array in Python but provides additional features, such as vectorized operations and automatic data alignment based on index labels.\nSuppose we have a Series representing the daily prices of a stock:\n\n\n\nDate\nPrice\n\n\n\n\n2024-03-18\n100\n\n\n2024-03-19\n105\n\n\n2024-03-20\n98\n\n\n2024-03-21\n102\n\n\n\nWe can create a Pandas Series to represent this data:\n\nimport pandas as pd\n\n# Stock price data\ndata = ['2024-03-18', '2024-03-19', '2024-03-20', '2024-03-21']\nprices = [100, 105, 98, 102]\n\n# Creating a Pandas Series\nstock_price_series = pd.Series(prices, index=pd.to_datetime(data), name='Stock Price')\nprint(stock_price_series)\n\n2024-03-18    100\n2024-03-19    105\n2024-03-20     98\n2024-03-21    102\nName: Stock Price, dtype: int64\n\n\n\n\n6.4.2 DataFrame\nA DataFrame is a two-dimensional data structure similar to a database table or an Excel spreadsheet. It consists of rows and columns, where each column can contain a different data type. Each column and row in a DataFrame has a unique label called an index and a name, respectively. The DataFrame allows for a wide range of data manipulation and analysis operations, such as indexing, filtering, aggregation, cleaning, among others.\nSuppose we have a DataFrame representing the daily prices of multiple stocks. We can create a Pandas DataFrame to represent this data. See the example below.\n\nimport pandas as pd\nimport numpy as np\n\n# Stock price data\ndata = ['2024-03-18', '2024-03-19', '2024-03-20', '2024-03-21']\nstock_prices = {\n    'Stock 1': [100, 105, np.nan, 102],\n    'Stock 2': [50, 52, 48, 49],\n    'Stock 3': [75, np.nan, 72, 74]\n}\n\n# Creating a Pandas DataFrame\ndf_stock_prices = pd.DataFrame(stock_prices, index=pd.to_datetime(data))\nprint(df_stock_prices)\n\n            Stock 1  Stock 2  Stock 3\n2024-03-18    100.0       50     75.0\n2024-03-19    105.0       52      NaN\n2024-03-20      NaN       48     72.0\n2024-03-21    102.0       49     74.0\n\n\n\n\n6.4.3 Main Functionalities\nThe df.isna() function is a function provided by Pandas in a DataFrame (df) that returns a boolean matrix indicating whether each element in the DataFrame is a missing value (NaN).\nWhen applied to a DataFrame, the isna() function returns a DataFrame with the same shape, where each value is replaced by True if it is NaN and False otherwise.\nThis is useful for quickly identifying missing values in a DataFrame and performing data cleaning or handling operations, such as filling missing values or removing rows or columns containing these values.\nIf we apply df_stock_prices.isna(), we get:\n\ndf_stock_prices.isna()\n\n            Stock 1  Stock 2  Stock 3\n2024-03-18    False    False    False\n2024-03-19    False    False     True\n2024-03-20     True    False    False\n2024-03-21    False    False    False\n\n\nTo count the number of NaN values in each column, combine is.na() with sum():\n\ndf_stock_prices.isna().sum()\n\nStock 1    1\nStock 2    0\nStock 3    1\ndtype: int64\n\n\nThe dropna() method in Pandas is used to remove rows or columns that contain missing values (NaN).\n\ndf_stock_prices.dropna()\n\n            Stock 1  Stock 2  Stock 3\n2024-03-18    100.0       50     75.0\n2024-03-21    102.0       49     74.0\n\n\nThe subset parameter is used to specify in which columns or rows Pandas should look for missing values before removing. When we use df.dropna(subset=[\"Stock 3\"]), we are instructing Pandas to remove all rows where there is a missing value in the “Stock 3” column.\n\ndf_stock_prices.dropna(subset=[\"Stock 3\"])\n\n            Stock 1  Stock 2  Stock 3\n2024-03-18    100.0       50     75.0\n2024-03-20      NaN       48     72.0\n2024-03-21    102.0       49     74.0\n\n\nIn the dropna() function, the inplace=True parameter specifies that the modification should be made directly to the original DataFrame, rather than returning a new DataFrame without the missing values. When inplace=True is used with dropna(), the original DataFrame is modified, and the rows or columns with missing values are permanently removed.\n\ndf_stock_prices.dropna(inplace = True)\n\nThe fillna() function in Pandas is used to fill missing values (NaN) in a DataFrame with a specific value.\nConsider the following DataFrame df representing customer data from a bank with some missing data:\n\nimport pandas as pd\nimport numpy as np\n\ndata = {'Name': [\"John\", \"Mary\", \"Peter\", \"Anna\", \"Marianne\"],\n        'Age': [25, 30, np.nan, 40, 35],\n        'Monthly Income': [5000, 6000, np.nan, 4500, 5500],\n        'Credit Limit': [10000, np.nan, 8000, 12000, np.nan]}\ndf_customers = pd.DataFrame(data)\n\nIn this example,\n\nThe missing values in the “Age” column will be filled with the median of the existing ages in the DataFrame.\nThe missing values in the “Credit Limit” column will be filled with the mode of the existing credit limits in the DataFrame.\nThe missing values in the “Monthly Income” column will be filled with the mean of the existing monthly incomes in the DataFrame.\n\nSee the code below.\n\n# Filling missing values in the 'Age' column with the median of existing ages\ndf_customers['Age'] = df_customers['Age'].fillna(df_customers['Age'].median())\n\n# Filling missing values in the 'Credit Limit' column with the mode of existing credit limits\ndf_customers['Credit Limit'] = df_customers['Credit Limit'].fillna(df_customers['Credit Limit'].mode()[0])\n\n# Filling missing values in the 'Monthly Income' column with the mean of existing monthly incomes\ndf_customers['Monthly Income'] = df_customers['Monthly Income'].fillna(df_customers['Monthly Income'].mean())\n\ndf_customers\n\n       Name   Age  Monthly Income  Credit Limit\n0      John  25.0          5000.0       10000.0\n1      Mary  30.0          6000.0        8000.0\n2     Peter  32.5          5250.0        8000.0\n3      Anna  40.0          4500.0       12000.0\n4  Marianne  35.0          5500.0        8000.0\n\n\nNow, let’s load the gapminder data, which is in the gapminder.zip file.\n\ngapminder = pd.read_csv(\"data/gapminder.zip\", sep = \"\\t\")\n\nThe head() function is used to view the first few rows of the gapminder dataset, providing a quick overview of its structure and content.\n\ngapminder.head()\n\n       country continent  year  lifeExp       pop   gdpPercap\n0  Afghanistan      Asia  1952   28.801   8425333  779.445314\n1  Afghanistan      Asia  1957   30.332   9240934  820.853030\n2  Afghanistan      Asia  1962   31.997  10267083  853.100710\n3  Afghanistan      Asia  1967   34.020  11537966  836.197138\n4  Afghanistan      Asia  1972   36.088  13079460  739.981106\n\n\nThe info() method provides information about the dataset, including the number of entries, the data type of each column, and whether there are any null values.\n\ngapminder.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 1704 entries, 0 to 1703\nData columns (total 6 columns):\n #   Column     Non-Null Count  Dtype  \n---  ------     --------------  -----  \n 0   country    1704 non-null   object \n 1   continent  1704 non-null   object \n 2   year       1704 non-null   int64  \n 3   lifeExp    1704 non-null   float64\n 4   pop        1704 non-null   int64  \n 5   gdpPercap  1704 non-null   float64\ndtypes: float64(2), int64(2), object(2)\nmemory usage: 80.0+ KB\n\n\nThe describe() function generates descriptive statistics for each numeric column in the dataset, such as count, mean, standard deviation, minimum, and maximum.\n\ngapminder.describe()\n\n             year      lifeExp           pop      gdpPercap\ncount  1704.00000  1704.000000  1.704000e+03    1704.000000\nmean   1979.50000    59.474439  2.960121e+07    7215.327081\nstd      17.26533    12.917107  1.061579e+08    9857.454543\nmin    1952.00000    23.599000  6.001100e+04     241.165876\n25%    1965.75000    48.198000  2.793664e+06    1202.060309\n50%    1979.50000    60.712500  7.023596e+06    3531.846988\n75%    1993.25000    70.845500  1.958522e+07    9325.462346\nmax    2007.00000    82.603000  1.318683e+09  113523.132900\n\n\nThe value_counts() function counts the number of occurrences of each category in the “continent” column of the gapminder dataset, transforms the results into a DataFrame, renames the columns to “continent” and “n” (indicating the count), and resets the index.\n\ngapminder.value_counts(\"continent\").to_frame(\"n\").reset_index()\n\n  continent    n\n0    Africa  624\n1      Asia  396\n2    Europe  360\n3  Americas  300\n4   Oceania   24\n\n\nIn the following snippet, we perform a value count for the unique combinations of categories in the “continent” and “year” columns of the gapminder DataFrame. The results are transformed into a DataFrame, renamed as “continent”, “year”, and “n” (indicating the count), and the index is reset.\n\ngapminder.value_counts([\"continent\", \"year\"]).to_frame(\"n\").reset_index()\n\n   continent  year   n\n0     Africa  1952  52\n1     Africa  1987  52\n2     Africa  1957  52\n3     Africa  2002  52\n4     Africa  1997  52\n5     Africa  1992  52\n6     Africa  2007  52\n7     Africa  1982  52\n8     Africa  1977  52\n9     Africa  1972  52\n10    Africa  1967  52\n11    Africa  1962  52\n12      Asia  1952  33\n13      Asia  2007  33\n14      Asia  2002  33\n15      Asia  1997  33\n16      Asia  1992  33\n17      Asia  1987  33\n18      Asia  1977  33\n19      Asia  1972  33\n20      Asia  1967  33\n21      Asia  1962  33\n22      Asia  1957  33\n23      Asia  1982  33\n24    Europe  1982  30\n25    Europe  1957  30\n26    Europe  2007  30\n27    Europe  2002  30\n28    Europe  1997  30\n29    Europe  1992  30\n30    Europe  1987  30\n31    Europe  1977  30\n32    Europe  1972  30\n33    Europe  1967  30\n34    Europe  1962  30\n35    Europe  1952  30\n36  Americas  2002  25\n37  Americas  2007  25\n38  Americas  1952  25\n39  Americas  1962  25\n40  Americas  1967  25\n41  Americas  1972  25\n42  Americas  1977  25\n43  Americas  1982  25\n44  Americas  1987  25\n45  Americas  1992  25\n46  Americas  1997  25\n47  Americas  1957  25\n48   Oceania  1982   2\n49   Oceania  2002   2\n50   Oceania  1997   2\n51   Oceania  1992   2\n52   Oceania  1987   2\n53   Oceania  1957   2\n54   Oceania  1977   2\n55   Oceania  1972   2\n56   Oceania  1967   2\n57   Oceania  1962   2\n58   Oceania  1952   2\n59   Oceania  2007   2"
  },
  {
    "objectID": "06-visualizacao_python.html#tidy-data",
    "href": "06-visualizacao_python.html#tidy-data",
    "title": "6  Data Processing and Visualization",
    "section": "6.5 Tidy Data",
    "text": "6.5 Tidy Data\nAll the tables below contain the same data (taken from the tidyr package in R), which shows the number of cases of a disease and the total population of some countries.\n\ntable1 = pd.read_csv(\"data/table1.csv\")\ntable2 = pd.read_csv(\"data/table2.csv\")\ntable3 = pd.read_csv(\"data/table3.csv\")\ntable4a = pd.read_csv(\"data/table4a.csv\")\ntable4b = pd.read_csv(\"data/table4b.csv\")\n\n\ntable1\n\n       country  year   cases  population\n0  Afghanistan  1999     745    19987071\n1  Afghanistan  2000    2666    20595360\n2       Brazil  1999   37737   172006362\n3       Brazil  2000   80488   174504898\n4        China  1999  212258  1272915272\n5        China  2000  213766  1280428583\n\n\n\ntable2\n\n        country  year        type       count\n0   Afghanistan  1999       cases         745\n1   Afghanistan  1999  population    19987071\n2   Afghanistan  2000       cases        2666\n3   Afghanistan  2000  population    20595360\n4        Brazil  1999       cases       37737\n5        Brazil  1999  population   172006362\n6        Brazil  2000       cases       80488\n7        Brazil  2000  population   174504898\n8         China  1999       cases      212258\n9         China  1999  population  1272915272\n10        China  2000       cases      213766\n11        China  2000  population  1280428583\n\n\n\ntable3\n\n       country  year               rate\n0  Afghanistan  1999       745/19987071\n1  Afghanistan  2000      2666/20595360\n2       Brazil  1999    37737/172006362\n3       Brazil  2000    80488/174504898\n4        China  1999  212258/1272915272\n5        China  2000  213766/1280428583\n\n\n\ntable4a\n\n       country    1999    2000\n0  Afghanistan     745    2666\n1       Brazil   37737   80488\n2        China  212258  213766\n\n\n\ntable4b\n\n       country        1999        2000\n0  Afghanistan    19987071    20595360\n1       Brazil   172006362   174504898\n2        China  1272915272  1280428583\n\n\nThe example below creates a new column called rate in the table1 DataFrame. The assign function adds a new column to the DataFrame, while the lambda expression calculates the values for this new column.\n\ntable1.assign(rate = lambda _: 10000 * (_.cases / _.population))\n\n       country  year   cases  population      rate\n0  Afghanistan  1999     745    19987071  0.372741\n1  Afghanistan  2000    2666    20595360  1.294466\n2       Brazil  1999   37737   172006362  2.193930\n3       Brazil  2000   80488   174504898  4.612363\n4        China  1999  212258  1272915272  1.667495\n5        China  2000  213766  1280428583  1.669488\n\n\nIn the example below, we group the data in the table1 DataFrame by the “year” column and then calculate the sum of cases for each year. The groupby(\"year\") method groups the data by year, creating separate groups for each year. as_index = False specifies that the column used for grouping (“year”) should not be set as the index in the resulting DataFrame. The agg method is used to perform an aggregation operation on the groups. Here, np.sum is used to calculate the sum of the values in the “cases” column for each group.\n\n(table1.groupby(\"year\", as_index = False)\n       .agg(total_cases = (\"cases\", np.sum)))\n\n   year  total_cases\n0  1999       250740\n1  2000       296920\n\n\nTo do the same with the data from table1, we have to use the pivot_table function:\n\ntable2_tidy = (table2.pivot_table(index = [\"country\", \"year\"], columns = \"type\", values = \"count\")\n               .reset_index()\n               .rename_axis(None, axis = 1))\n\ntable2_tidy.assign(rate = lambda _: 10000 * (_.cases / _.population))\n\n       country  year     cases    population      rate\n0  Afghanistan  1999     745.0  1.998707e+07  0.372741\n1  Afghanistan  2000    2666.0  2.059536e+07  1.294466\n2       Brazil  1999   37737.0  1.720064e+08  2.193930\n3       Brazil  2000   80488.0  1.745049e+08  4.612363\n4        China  1999  212258.0  1.272915e+09  1.667495\n5        China  2000  213766.0  1.280429e+09  1.669488\n\n\nIn the example above, we use the pivot_table method from Pandas to reorganize the data in the table2 DataFrame. It reorganizes the data so that the values in the “count” column are pivoted (transformed into columns) based on the unique values of the combination of “country” and “year”. The index, columns, and values parameters specify the columns to be used as the index, the columns to be transformed into columns, and the values to be filled in the pivot table, respectively. After the pivot operation, additional methods are chained to modify the structure of the resulting DataFrame:\n\nreset_index() resets the DataFrame’s indices to default numeric indices, moving the previous indices (in this case, “country” and “year”) to columns.\nrename_axis(None, axis=1) removes the column index names, replacing them with None. This is done specifically to clean up the column names of the DataFrame.\n\nAfter transforming the data, the assign function is used to create a new column called rate in the resulting DataFrame table2_tidy.\nNow, let’s do the same for table4a and table4b:\n\ntable4_tidy = (table4a.melt(id_vars = \"country\", value_vars = [\"1999\", \"2000\"], var_name = \"year\", value_name = \"cases\")\n                .merge(table4b.melt(id_vars = \"country\", value_vars = [\"1999\", \"2000\"], var_name = \"year\", value_name = \"population\"),\n                       on = (\"country\", \"year\")))\n\ntable4_tidy.assign(rate = lambda _: 10000 * (_.cases / _.population))\n\n       country  year   cases  population      rate\n0  Afghanistan  1999     745    19987071  0.372741\n1       Brazil  1999   37737   172006362  2.193930\n2        China  1999  212258  1272915272  1.667495\n3  Afghanistan  2000    2666    20595360  1.294466\n4       Brazil  2000   80488   174504898  4.612363\n5        China  2000  213766  1280428583  1.669488\n\n\nThe DataFrames table4a and table4b are melted using the melt method:\n\nFor table4a, the columns that will remain fixed are specified through the argument id_vars = \"country\", while the columns “1999” and “2000” are melted as variables using value_vars = [\"1999\", \"2000\"]. The names of the melted variables are renamed to “year” and “cases” using var_name = \"year\" and value_name = \"cases\", respectively.\nSimilarly, for table4b, the columns “country” and “1999”, “2000” are melted, with the variable names renamed to “year” and “population”, respectively.\n\nThe DataFrames resulting from the melting of table4a and table4b are merged using the merge method. The merge is performed based on the columns “country” and “year”, ensuring that corresponding data from table4a and table4b are correctly combined.\nFinally, the assign method is used to create a new column called “rate”, which represents the number of cases per 10,000 inhabitants.\nFor table3, just split the cases column using the separator /:\n\nprint(table3)\n\n       country  year               rate\n0  Afghanistan  1999       745/19987071\n1  Afghanistan  2000      2666/20595360\n2       Brazil  1999    37737/172006362\n3       Brazil  2000    80488/174504898\n4        China  1999  212258/1272915272\n5        China  2000  213766/1280428583\n\ntable3_tidy = (table3.assign(cases = lambda _: _.rate.str.split(\"/\", expand = True)[0].astype(int),\n                       population = lambda _: _.rate.str.split(\"/\",  expand = True)[1].astype(int))\n               .drop(\"rate\", axis = 1))\n\ntable3_tidy\n\n       country  year   cases  population\n0  Afghanistan  1999     745    19987071\n1  Afghanistan  2000    2666    20595360\n2       Brazil  1999   37737   172006362\n3       Brazil  2000   80488   174504898\n4        China  1999  212258  1272915272\n5        China  2000  213766  1280428583\n\ntable3_tidy.assign(rate = lambda _: 10000 * (_.cases / _.population))\n\n       country  year   cases  population      rate\n0  Afghanistan  1999     745    19987071  0.372741\n1  Afghanistan  2000    2666    20595360  1.294466\n2       Brazil  1999   37737   172006362  2.193930\n3       Brazil  2000   80488   174504898  4.612363\n4        China  1999  212258  1272915272  1.667495\n5        China  2000  213766  1280428583  1.669488\n\n\nThe expand parameter is used in the str.split() method to specify whether the split result should be expanded into a DataFrame (if True) or kept as a list of values (if False, which is the default).\nMain functionalities - see Paulo’s lectures"
  },
  {
    "objectID": "06-visualizacao_python.html#data-visualization",
    "href": "06-visualizacao_python.html#data-visualization",
    "title": "6  Data Processing and Visualization",
    "section": "6.6 Data Visualization",
    "text": "6.6 Data Visualization\nTwo widely used libraries for visualization in Python are Matplotlib and Plotnine. Matplotlib offers a wide range of options to create static visualizations, from simple charts to complex and customized graphs. On the other hand, Plotnine is a library based on the grammar of graphics (similar to R’s ggplot2), which makes it easy to create elegant and concise visualizations using an intuitive and expressive syntax.\n\n6.6.1 Matplotlib\nBefore we start creating visualizations, it’s important to understand some basic concepts of Matplotlib:\n\nFigure and Axes: In Matplotlib, a figure is the window or page where everything is drawn. Within a figure, there can be multiple axes (or subplots), where data is effectively plotted.\nThe plot() Method: The plot() method is used to create line, point, or marker charts. It accepts various arguments to customize the appearance of the graph, such as color, line style, line width, etc.\nCustomization: Matplotlib offers many customization options to adjust the appearance of charts, including adding axis labels, chart titles, legends, and more.\n\nNow let’s see an example of how to create a scatter plot using fictitious data, where each data unit is related to a company.\n\nimport matplotlib.pyplot as plt\n\n# Example data: Company names, revenue, and number of employees\ncompanies = ['A', 'B', 'C', 'D', 'E']\nrevenue = [200, 300, 400, 250, 350]  # in millions of reais\nemployees = [1000, 1200, 1500, 900, 1100]\n\n# Creating the scatter plot\nplt.figure(figsize=(8, 6))\nplt.scatter(revenue, employees, color='blue', marker='o')\n\n# Adding labels and title\nplt.xlabel('Revenue (in millions of reais)')\nplt.ylabel('Number of Employees')\nplt.title('Revenue vs. Number of Employees')\n\n# Adding annotations for each point\nfor i in range(len(companies)):\n    plt.annotate(companies[i], (revenue[i], employees[i]))\n\n# Displaying the plot\nplt.grid(True)\nplt.show()\n\n\n\n\nIn this example, each point on the graph represents a company, where the x-axis represents revenue (in millions of reais) and the y-axis represents the number of employees. Annotations are used to identify each company on the graph.\nNext, we use Matplotlib to create a line graph representing the sales evolution of two products over several years. Each point on the graph represents the number of sales in a specific year.\n\nimport matplotlib.pyplot as plt\n\n# Example data: Years and product sales\nyears = [2010, 2011, 2012, 2013, 2014, 2015, 2016]\nproduct_A_sales = [500, 600, 550, 700, 800, 750, 900]\nproduct_B_sales = [400, 450, 500, 550, 600, 650, 700]\n\n# Creating the line plot\nplt.figure(figsize=(10, 6))\nplt.plot(years, product_A_sales, marker='o', label='Product A')\nplt.plot(years, product_B_sales, marker='s', label='Product B')\n\n# Adding labels and title\nplt.xlabel('Year')\nplt.ylabel('Sales')\nplt.title('Sales over Time')\n\n# Adding legend\nplt.legend()\n\n# Displaying the plot\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n6.6.2 Plotnine\nPlotnine is a Python library that allows the creation of statistical data visualizations in a simple and concise way, using the grammar of graphics from R (also known as ggplot2). This grammar consists of a declarative approach to chart construction, where visual elements are added in layers to form the final graph.\n\nfrom plotnine import *\n\nTo illustrate, let’s use the gapminder dataset.\n\n((ggplot(gapminder, aes(x = \"continent\", fill = \"continent\")) +\n     geom_bar(aes(y = \"stat(count) / 12\"), alpha = 0.75) +\n     labs(x = \"\", y = \"Number of countries\", title = \"Continents\") +\n     theme(legend_position = \"none\") +\n     coord_flip()+\n     theme_bw())\n     .show())\n\n\n((ggplot(gapminder, aes(x = \"lifeExp\", y = \"stat(density)\")) +\n     geom_histogram(fill = \"blue\", color = \"white\", alpha = 0.5) +\n     labs(x = \"Life Expectancy\", y = \"\", title = \"Gapminder\"))\n     .show())\n\n\n((ggplot(gapminder, aes(x = \"lifeExp\", y = \"stat(density)\")) +\n     geom_histogram(fill = \"blue\", color = \"white\", alpha = 0.5) +\n     labs(x = \"Life Expectancy\", y = \"\", title = \"Gapminder\") +\n     facet_wrap(\"~ continent\", nrow = 1) +\n     theme(figure_size = (12, 2))).\n     show)\n\n\n((gapminder.groupby([\"continent\", \"year\"], as_index = False)\n      .agg(median_lifeExp = (\"lifeExp\", np.median))\n      .pipe(lambda _: ggplot(_, aes(x = \"year\", y = \"median_lifeExp\", color = \"continent\")) +\n                          geom_line(size = 0.75) +\n                          geom_point(size = 1.5) +\n                          labs(x = \"Year\", y = \"Median Life Expectancy\", color = \"Continent\", title = \"Gapminder\")))\n                          .show())"
  },
  {
    "objectID": "08-prova.html",
    "href": "08-prova.html",
    "title": "7  Exam",
    "section": "",
    "text": "The dataset relinc.csv presents the count of individuals from different religious groups according to different income ranges in the USA. The original file is structured so that each row represents a different religion, each column represents a different income range, and the cells contain the count of individuals belonging to the corresponding religion and income range.\n\n\n\n\n\nreligion\n&lt;10k\n10-20k\n20-30k\n30-40k\n40-50k\n50-75k\n75-100k\n100-150k\n&gt;150k\nrefused\n\n\n\n\nAgnostic\n27\n34\n60\n81\n76\n137\n122\n109\n84\n96\n\n\nAtheist\n12\n27\n37\n52\n35\n70\n73\n59\n74\n76\n\n\nBuddhist\n27\n21\n30\n34\n33\n58\n62\n39\n53\n54\n\n\nCatholic\n418\n617\n732\n670\n638\n1116\n949\n792\n633\n1489\n\n\nrefused\n15\n14\n15\n11\n10\n35\n21\n17\n18\n116\n\n\nEvangelical Prot\n575\n869\n1064\n982\n881\n1486\n949\n723\n414\n1529\n\n\nHindu\n1\n9\n7\n9\n11\n34\n47\n48\n54\n37\n\n\nHistorically Black Prot\n228\n244\n236\n238\n197\n223\n131\n81\n78\n339\n\n\nJehovah's Witness\n20\n27\n24\n24\n21\n30\n15\n11\n6\n37\n\n\nJewish\n19\n19\n25\n25\n30\n95\n69\n87\n151\n162\n\n\nMainline Prot\n289\n495\n619\n655\n651\n1107\n939\n753\n634\n1328\n\n\nMormon\n29\n40\n48\n51\n56\n112\n85\n49\n42\n69\n\n\nMuslim\n6\n7\n9\n10\n9\n23\n16\n8\n6\n22\n\n\nOrthodox\n13\n17\n23\n32\n32\n47\n38\n42\n46\n73\n\n\nOther Christian\n9\n7\n11\n13\n13\n14\n18\n14\n12\n18\n\n\nOther Faiths\n20\n33\n40\n46\n49\n63\n46\n40\n41\n71\n\n\nOther World Religions\n5\n2\n3\n4\n2\n7\n3\n4\n4\n8\n\n\nUnaffiliated\n217\n299\n374\n365\n341\n528\n407\n321\n258\n597\n\n\n\n\n\n\n\n\n(a)\nRead the relinc.csv file available in BlackBoard  and adjust it to fit the tidy data format, meaning:\n\nEach variable is a column; each column represents a variable,\nEach observation is a row; each row represents an observation,\nEach value is a cell; each cell contains a single value.\n\nThe final table shoud have three columns: Religion, Income, Count.\n\n\n(b)\nReturn a table showing the total number of people for each religion and another table showing the total number of people in each income range.\n\n\n(c)\nList the existing categories of the religion variable and print them. Select only those religions that do not start with “Other” and exclude those who refused to disclose their religion (category “refused”) or income range.\n\n\n(d)\nFor the table resulting from item (c), create a new variable with the midpoint of each income range as follows:\n\n\n\nIncome Range\nMidpoint\n\n\n\n\n&lt;10k\n5k\n\n\n10-20k\n15k\n\n\n20-30k\n25k\n\n\n30-40k\n35k\n\n\n40-50k\n45k\n\n\n50-75k\n62.5k\n\n\n75-100k\n87.5k\n\n\n100-150k\n125k\n\n\n&gt;150k\n175k *\n\n\n\nThen, calculate an approximation of the average income for each religion, using the midpoint of each income range.\n\n\n(e)\nReturn the religion that had, on average, the highest and lowest income."
  }
]